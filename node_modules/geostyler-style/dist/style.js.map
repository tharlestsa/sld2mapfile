{"version":3,"file":"style.js","sourceRoot":"","sources":["../style.ts"],"names":[],"mappings":";;AA+BC,CAAC","sourcesContent":["import {\n  GeoStylerBooleanFunction,\n  GeoStylerFunction,\n  GeoStylerNumberFunction,\n  GeoStylerStringFunction\n} from './functions';\n\n/**\n * The ScaleDenominator defines a range of scales.\n */\nexport interface ScaleDenominator {\n  /**\n   * Minimum value of the ScaleDenominator. The value is inclusive.\n   *\n   */\n  min?: Expression<number>;\n  /**\n   * Maximum value of the ScaleDenominator. The value is exclusive.\n   */\n  max?: Expression<number>;\n}\n\n/**\n * Expression that evaluates to the result of a function\n * call on a list of argument expressions.\n */\nexport interface FunctionCall<T> {\n  name: T extends string ? GeoStylerStringFunction['name'] :\n    T extends number ? GeoStylerNumberFunction['name'] :\n    GeoStylerBooleanFunction['name'];\n  args: Expression<PropertyType>[];\n};\n\n/**\n * Expressions can be a literal value, a property name or a function call.\n */\nexport type Expression<T extends PropertyType> =\n  T extends string ? GeoStylerStringFunction | T :\n  T extends number ? GeoStylerNumberFunction | T :\n  T extends boolean ? GeoStylerBooleanFunction | T :\n  T;\n\n/**\n * The type of the Style.\n */\nexport type StyleType = 'Point' | 'Fill' | 'Line' | 'Raster';\n\n/**\n * A datatype of a property of the data.\n */\nexport type PropertyType = string | number | boolean | unknown;\n\n/**\n * The possible Operators used for comparison Filters.\n */\nexport type ComparisonOperator = '==' | '*=' | '!=' | '<' | '<=' | '>' | '>=' | '<=x<=';\n\n/**\n * The possible Operators used for combination Filters.\n */\nexport type CombinationOperator = '&&' | '||';\n\n/**\n * The Operator used for negation Filters.\n */\nexport type NegationOperator = '!';\n\n/**\n * All operators.\n */\nexport type Operator = ComparisonOperator | CombinationOperator | NegationOperator;\n\n/**\n * A Filter that checks if a property is in a range of two values (inclusive).\n */\nexport type RangeFilter = [\n  '<=x<=',\n  Expression<string>,\n  Expression<number>,\n  Expression<number>\n];\n\n/**\n * A ComparisonFilter compares two values.\n * If the fist argument is a GeoStylerFunction it will be evaluated it.\n * If it is a string it will be treated as key of an object.\n */\nexport type ComparisonFilter = [\n  ComparisonOperator,\n  Expression<string | number | boolean | null>,\n  Expression<string | number | boolean | null>\n] | RangeFilter;\n\n/**\n * A CombinationFilter combines N Filters with a logical OR / AND operator.\n */\nexport type CombinationFilter = [\n  CombinationOperator,\n  ...Filter[]\n];\n\n/**\n * A NegationFilter negates a given Filter.\n */\nexport type NegationFilter = [\n  NegationOperator,\n  Filter\n];\n\nexport type Filter = ComparisonFilter | NegationFilter | CombinationFilter;\n\n/**\n * The kind of the Symbolizer\n */\nexport type SymbolizerKind = 'Fill' | 'Icon' | 'Line' | 'Text' | 'Mark' | 'Raster';\n\n/**\n * A Symbolizer describes the style representation of geographical data.\n */\nexport interface BaseSymbolizer {\n  /**\n   * Describes the type of the kind of the Symbolizer.\n   */\n  kind: SymbolizerKind;\n  /**\n   * A color defined as a hex-color string.\n   */\n  color?: Expression<string>;\n  /**\n   * Determines the total opacity for the Symbolizer.\n   * A value between 0 and 1. 0 is none opaque and 1 is full opaque.\n   */\n  opacity?: Expression<number>;\n  /**\n   * Defines whether the Symbolizer should be visibile or not.\n   */\n  visibility?: Expression<boolean>;\n}\n\n/**\n * A PointSymbolizer describes the style representation of POINT data.\n */\nexport interface BasePointSymbolizer extends BaseSymbolizer {\n  /**\n   * This is a property relevant if using tiled datasets.\n   * If true, the symbols will not cross tile edges to avoid mutual collisions.\n   */\n  avoidEdges?: Expression<boolean>;\n  /**\n   * The offset of the Symbolizer as [x, y] coordinates. Positive values indicate\n   * right and down, while negative values indicate left and up.\n   */\n  offset?: [Expression<number>, Expression<number>];\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-icon-translate-anchor\n   */\n  offsetAnchor?: 'map' | 'viewport';\n}\n\n/**\n * Template literal to be more precise on what a font specification of a wellknownname can look like.\n * font-based symbols following Geotools/Geoserver syntax: ttf://<font name>#<hex code>\n */\nexport type FontSpec = `ttf://${string}#0x${string}`;\n\n/**\n * Supported WellKnownNames\n * Note that due to TypeScript limitations any string will be valid for this type; this will not change\n * until regexp or equivalent is supported, see:\n * https://github.com/microsoft/TypeScript/issues/6579\n *\n */\nexport type WellKnownName = 'circle' | 'square' | 'triangle' | 'star' | 'cross' | 'x'\n| 'shape://vertline' | 'shape://horline' | 'shape://slash'\n| 'shape://backslash' | 'shape://dot' | 'shape://plus'\n| 'shape://times' | 'shape://oarrow' | 'shape://carrow'\n| FontSpec;\n\n/**\n * Unit that defines how to handle the corresponding symbolizer property.\n * Default should be pixel in your parser.\n * 'px' => pixel\n * 'm' => meter\n */\nexport type DistanceUnit = 'px' | 'm';\n\n/**\n * MarkSymbolizer describes the style representation of POINT data, if styled as\n * with a regular geometry.\n */\nexport interface MarkSymbolizer extends BasePointSymbolizer {\n  kind: 'Mark';\n  /**\n   * The WellKnownName of the MarkSymbolizer.\n   */\n  wellKnownName: WellKnownName;\n  /**\n   * The radius of the Symbolizer. Values describing the full size of the Symbolizer\n   * have to be divided by two (pixels if radiusUnit is not defined).\n   */\n  radius?: Expression<number>;\n  /**\n   * Unit to use for the radius.\n   */\n  radiusUnit?: DistanceUnit;\n  /**\n   * The rotation of the Symbolizer in degrees. Value should be between 0 and 360.\n   */\n  rotate?: Expression<number>;\n  /**\n   * The opacity of the fill. A value between 0 and 1.\n   * 0 is none opaque and 1 is full opaque.\n   */\n  fillOpacity?: Expression<number>;\n  /**\n   * The color of the stroke represented as a hex-color string.\n   */\n  strokeColor?: Expression<string>;\n  /**\n   * The opacity of the stroke. A value between 0 and 1.\n   * 0 is none opaque and 1 is full opaque.\n   */\n  strokeOpacity?: Expression<number>;\n  /**\n   * The width of the stroke (pixels if strokeWidthUnit is not defined).\n   */\n  strokeWidth?: Expression<number>;\n  /**\n   * Unit to use for the strokeWidth.\n   */\n  strokeWidthUnit?: DistanceUnit;\n  /**\n   * Amount to blur the Symbolizer. 1 blurs the Symbolizer such that only the\n   * centerpoint has full opacity. Mostly relevant for circles.\n   */\n  blur?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-circle-circle-pitch-alignment\n   */\n  pitchAlignment?: 'map' | 'viewport';\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-circle-circle-pitch-scale\n   */\n  pitchScale?: 'map' | 'viewport';\n}\n\n/**\n * The TextSymbolizer describes the style representation of point data, if styled\n * with a text.\n */\nexport interface TextSymbolizer extends BasePointSymbolizer {\n  kind: 'Text';\n  /**\n   * If true, the text will be visible even if it collides with other previously\n   * drawn symbols.\n   */\n  allowOverlap?: Expression<boolean>;\n  /**\n   * The anchor position of the label referred to the center of the geometry.\n   */\n  anchor?: 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  /**\n   * Template string where {{PROPERTYNAME}} can be used to be replaced by values\n   * from the dataset.\n   * e.g.: \"Name {{country_name}}\"\n   */\n  label?: Expression<string>;\n  /**\n   * An Array of fonts. Comparable to https://www.w3schools.com/cssref/pr_font_font-family.asp\n   */\n  font?: Expression<string>[];\n  /**\n   * The halo's fadeout distance towards the outside.\n   */\n  haloBlur?: Expression<number>;\n  /**\n   * The color of the text's halo, which helps it stand out from backgrounds\n   * represented as a hex-color string.\n   */\n  haloColor?: Expression<string>;\n  /**\n   * Distance of halo to the font outline (pixels if haloWidthUnit is not defined).\n   */\n  haloWidth?: Expression<number>;\n  /**\n   * Unit to use for the haloWidth.\n   */\n  haloWidthUnit?: DistanceUnit;\n  /**\n   * The opacity of the halo. A value between 0 and 1.\n   * 0 means no opacity (i.e. transparent) and 1 is fully opaque.\n   */\n  haloOpacity?: Expression<number>;\n  /**\n   * Text justification option to align the text.\n   */\n  justify?: 'left' | 'center' | 'right';\n  /**\n   * If true, the text will be kept upright.\n   */\n  keepUpright?: Expression<boolean>;\n  /**\n   * Sets the spacing between text characters (pixels if letterSpacingUnit is not defined).\n   */\n  letterSpacing?: Expression<number>;\n  /**\n   * Unit to use for the letterSpacing.\n   */\n  letterSpacingUnit?: DistanceUnit | 'em';\n  /**\n   * Sets the line height (pixels if lineHeightUnit is not defined).\n   * 'em' -> fontsize\n   */\n  lineHeight?: Expression<number>;\n  /**\n   * Unit to use for the lineHeight.\n   * 'em' -> fontsize\n   */\n  lineHeightUnit?: DistanceUnit | 'em';\n  /**\n   * Maximum angle change between adjacent characters in degrees.\n   */\n  maxAngle?: Expression<number>;\n  /**\n   * The maximum line width for text wrapping.\n   */\n  maxWidth?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * If true, icons will display without their corresponding text when the text\n   * collides with other symbols and the icon does not.\n   */\n  optional?: Expression<boolean>;\n  /**\n   * Size of the additional area around the text bounding box used for detecting\n   * symbol collisions.\n   */\n  padding?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-pitch-alignment\n   */\n  pitchAlignment?: 'map' | 'viewport' | 'auto';\n  /**\n   * The rotation of the Symbolizer in degrees. Value should be between 0 and 360.\n   */\n  rotate?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-rotation-alignment\n   */\n  rotationAlignment?: 'map' | 'viewport' | 'auto';\n  /**\n   * The fontsize in pixels.\n   */\n  size?: Expression<number>;\n  /**\n   * Specifies how to capitalize text, similar to the CSS text-transform property.\n   */\n  transform?: 'none' | 'uppercase' | 'lowercase';\n  /**\n   * Specifies whether a font should be styled with a normal, italic, or oblique\n   * face from its font-family.\n   */\n  fontStyle?: 'normal' | 'italic' | 'oblique';\n  /**\n   * Specifies the weight (or boldness) of the font. The weights available depend\n   * on the font-family you are using.\n   */\n  fontWeight?: 'normal' | 'bold';\n}\n\n/**\n * An IconSymbolizer describes the style representation of POINT data if styled\n * with a specific icon.\n */\nexport interface IconSymbolizer extends BasePointSymbolizer {\n  kind: 'Icon';\n  /**\n   * If true, the icon will be visible even if it collides with other previously\n   * drawn symbols.\n   */\n  allowOverlap?: Expression<boolean>;\n  /**\n   * Part of the icon placed closest to the anchor. This may conflict with a set\n   * offset.\n   */\n  anchor?: 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  /**\n   * The halo's fadeout distance towards the outside.\n   */\n  haloBlur?: Expression<number>;\n  /**\n   * The color of the icons halo, which helps it stand out from backgrounds represented\n   * as a hex-color string.\n   */\n  haloColor?: Expression<string>;\n  /**\n   * Distance of halo to the icons outline (pixels if haloWidthUnit is not defined).\n   */\n  haloWidth?: Expression<number>;\n  /**\n   * Unit to use for the haloWidth.\n   */\n  haloWidthUnit?: DistanceUnit;\n  /**\n   * The opacity of the halo. A value between 0 and 1.\n   * 0 means no opacity (i.e. transparent)  and 1 is fully opaque.\n   */\n  haloOpacity?: Expression<number>;\n  /**\n   * A path/URL to the icon image file.\n   */\n  image?: Expression<string>;\n  /**\n   * An optional configuration for the image format as MIME type.\n   * This might be needed if the image(path) has no filending specified. e.g. http://myserver/getImage\n   */\n  format?: `image/${'png' | 'jpg' | 'jpeg' | 'gif' | 'svg+xml'}`;\n  /**\n   * If true, the icon will be kept upright.\n   */\n  keepUpright?: Expression<boolean>;\n  /**\n   * Property relevant for mapbox-styles.\n   * If true, text will display without their corresponding icons when the icon\n   * collides with other symbols and the text does not.\n   */\n  optional?: Expression<boolean>;\n  /**\n   * Size of the additional area around the icon used for detecting symbol collisions.\n   */\n  padding?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-pitch-alignment\n   */\n  pitchAlignment?: 'map' | 'viewport' | 'auto';\n  /**\n   * The rotation of the Symbolizer in degrees. Value should be between 0 and 360.\n   */\n  rotate?: Expression<number>;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-rotation-alignment\n   */\n  rotationAlignment?: 'map' | 'viewport' | 'auto';\n  /**\n   * The Symbolizer size (pixels if sizeUnit is not defined).\n   */\n  size?: Expression<number>;\n  /**\n   * Unit to use for the size.\n   */\n  sizeUnit?: DistanceUnit;\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-text-fit\n   */\n  textFit?: 'none' | 'width' | 'height' | 'both';\n  /**\n   * Property relevant for mapbox-styles.\n   * Compare https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-text-fit-padding\n   */\n  textFitPadding?: [Expression<number>, Expression<number>, Expression<number>, Expression<number>];\n}\n\n/**\n * A FillSymbolizer describes the style representation of POLYGON data.\n */\nexport interface FillSymbolizer extends BaseSymbolizer {\n  kind: 'Fill';\n  /**\n   * Whether the fill should be antialiased or not .\n   */\n  antialias?: Expression<boolean>;\n  /**\n   * The opacity of the fill. A value between 0 and 1.\n   * 0 is none opaque and 1 is full opaque.\n   */\n  fillOpacity?: Expression<number>;\n  /**\n   * The outline color as a hex-color string. Matches the value of fill-color if\n   * unspecified.\n   */\n  outlineColor?: Expression<string>;\n  /**\n   * The opacity of the outline. A value between 0 and 1.\n   * 0 is none opaque and 1 is full opaque.\n   */\n  outlineOpacity?: Expression<number>;\n  /**\n   * The outline width (pixels if outlineWidthUnit is not defined).\n   */\n  outlineWidth?: Expression<number>;\n  /**\n   * The Captype for the outLine.\n   */\n  outlineCap?: CapType;\n  /**\n   * The JoinType for the outLine.\n   */\n  outlineJoin?: JoinType;\n  /**\n   * Unit to use for the outlineWidth.\n   */\n  outlineWidthUnit?: DistanceUnit;\n  /**\n   * Encodes a dash pattern as an array of numbers. Odd-indexed numbers (first,\n   * third, etc) determine the length in pixels to draw the line, and even-indexed\n   * numbers (second, fourth, etc) determine the length in pixels to blank out\n   * the line. Default is an unbroken line.\n   */\n  outlineDasharray?: Expression<number>[];\n  /**\n   * Renders the fill of the polygon with a repeated pattern of PointSymbolizer.\n   */\n  graphicFill?: PointSymbolizer;\n}\n\n/**\n * The Types that are allowed in a graphic\n */\nexport type GraphicType = 'Mark' | 'Icon';\n\n/**\n * Determines how lines are rendered at their ends.\n * Possible values are butt (sharp square edge), round (rounded edge),\n * and square (slightly elongated square edge).\n */\nexport type CapType = 'butt' | 'round' | 'square';\n\n/**\n * Determines how lines are rendered at intersections of line segments.\n * Possible values are mitre (sharp corner),  round (rounded corner), and bevel\n * diagonal corner).\n */\nexport type JoinType = 'bevel' | 'round' | 'miter';\n\n/**\n * A LineSymbolizer describes the style representation of LINESTRING data.\n */\nexport interface LineSymbolizer extends BaseSymbolizer {\n  kind: 'Line';\n  blur?: Expression<number>;\n  /**\n   * The Captype for the LineSymbolizer.\n   */\n  cap?: CapType;\n  /**\n   * Encodes a dash pattern as an array of numbers. Odd-indexed numbers (first,\n   * third, etc) determine the length in pixels to draw the line, and even-indexed\n   * numbers (second, fourth, etc) determine the length in pixels to blank out\n   * the line. Default is an unbroken line.\n   */\n  dasharray?: Expression<number>[];\n  /**\n   * Number of pixels into the dasharray to offset the drawing of the dash,\n   * used to shift the location of the lines and gaps in a dash.\n   */\n  dashOffset?: Expression<number>;\n  /**\n   * Draws a line casing outside of a line's actual path. Value indicates the\n   * width of the inner gap (pixels if gapWidthUnit is not defined).\n   */\n  gapWidth?: Expression<number>;\n  /**\n   * Unit to use for the gapWidth.\n   */\n  gapWidthUnit?: DistanceUnit;\n  /**\n   * Defines a gradient with which to color a line feature.\n   */\n  gradient?: any[];\n  /**\n   * Renders the line with a repeated linear PointSymbolizer.\n   */\n  graphicStroke?: PointSymbolizer;\n  /**\n   * Renders the pixels of the line with a repeated pattern.\n   */\n  graphicFill?: PointSymbolizer;\n  /**\n   * The JoinType for the LineSymbolizer.\n   */\n  join?: JoinType;\n  /**\n   * Used to automatically convert miter joins to bevel joins for sharp angles.\n   */\n  miterLimit?: Expression<number>;\n  /**\n   * If present, it makes the renderer draw a line parallel to the original one,\n   * at the given distance. When applied on lines, positive values generate a\n   * parallel line on the left hand side, negative values on the right hand side.\n   */\n  perpendicularOffset?: Expression<number>;\n  /**\n   * Used to automatically convert round joins to miter joins for shallow angles.\n   */\n  roundLimit?: Expression<number>;\n  /**\n   * Distance between two symbol anchors (pixels if spacingUnit is not defined).\n   */\n  spacing?: Expression<number>;\n  /**\n   * Unit to use for the spacing.\n   * 'em' -> fontsize\n   */\n  spacingUnit?: DistanceUnit | 'em';\n  /**\n   * The width of the Line (pixels if widthUnit is not defined).\n   */\n  width?: Expression<number>;\n  /**\n   * Unit to use for the width.\n   */\n  widthUnit?: DistanceUnit;\n}\n\n/**\n * Operators used for Point symbolization.\n */\nexport type PointSymbolizer = IconSymbolizer | MarkSymbolizer | TextSymbolizer;\n\n/**\n * A single entry for the ColorMap.\n */\nexport interface ColorMapEntry {\n  color: Expression<string>;\n  quantity?: Expression<number>;\n  label?: Expression<string>;\n  opacity?: Expression<number>;\n}\n\n/**\n * The Types that are allowed in a ColorMap.\n */\nexport type ColorMapType = 'ramp' | 'intervals' | 'values';\n\n/**\n * A ColorMap defines the color values for the pixels of a raster image.\n */\nexport interface ColorMap {\n  type: ColorMapType;\n  colorMapEntries?: ColorMapEntry[];\n  extended?: Expression<boolean>;\n}\n\n/**\n * A ContrastEnhancement defines how the contrast of image data should be enhanced.\n */\nexport interface ContrastEnhancement {\n  enhancementType?: 'normalize' | 'histogram';\n  gammaValue?: Expression<number>;\n}\n\n/**\n * A Channel defines the properties for a color channel.\n */\nexport interface Channel {\n  sourceChannelName?: Expression<string>;\n  contrastEnhancement?: ContrastEnhancement;\n}\n\n/**\n * A RGBChannel defines how dataset bands are mapped to image color channels.\n */\nexport interface RGBChannel {\n  redChannel: Channel;\n  blueChannel: Channel;\n  greenChannel: Channel;\n}\n\n/**\n * A GrayChannel defines how a single dataset band is mapped to a grayscale channel.\n */\nexport interface GrayChannel {\n  grayChannel: Channel;\n}\n\nexport type ChannelSelection = RGBChannel | GrayChannel;\n\n/**\n * A RasterSymbolizer defines the style representation of RASTER data.\n */\nexport interface RasterSymbolizer {\n  kind: 'Raster';\n  visibility?: Expression<boolean>;\n  opacity?: Expression<number>;\n  colorMap?: ColorMap;\n  channelSelection?: ChannelSelection;\n  contrastEnhancement?: ContrastEnhancement;\n  hueRotate?: Expression<number>;\n  brightnessMin?: Expression<number>;\n  brightnessMax?: Expression<number>;\n  saturation?: Expression<number>;\n  contrast?: Expression<number>;\n  resampling?: 'linear' | 'nearest';\n  fadeDuration?: Expression<number>;\n}\n\n/**\n * All operators.\n */\nexport type Symbolizer = PointSymbolizer | LineSymbolizer | FillSymbolizer | RasterSymbolizer;\n\n/**\n * A Rule combines a specific amount of data (defined by a Filter and a\n * ScaleDenominator) and an associated Symbolizer.\n */\nexport interface Rule {\n  name: string;\n  filter?: Filter;\n  scaleDenominator?: ScaleDenominator;\n  symbolizers: Symbolizer[];\n}\n\n/**\n * The Style is the main interface and the root for all other interfaces.\n */\nexport interface Style {\n  name: string;\n  rules: Rule[];\n}\n\n/**\n * Interface for defining unsupported properties in the parsers.\n */\nexport interface UnsupportedProperties {\n  ScaleDenominator?: SupportDef;\n  Filter?: SupportDef | {\n    '&&'?: SupportDef;\n    '!'?: SupportDef;\n    '||'?: SupportDef;\n    '>'?: SupportDef;\n    '>='?: SupportDef;\n    '=='?: SupportDef;\n    '<'?: SupportDef;\n    '<='?: SupportDef;\n    '!='?: SupportDef;\n    '*='?: SupportDef;\n  };\n  Symbolizer?: SupportDef | {\n    LineSymbolizer?: SupportDef | {\n      [key in keyof Required<LineSymbolizer>]?: SupportDef\n    };\n    FillSymbolizer?: SupportDef | {\n      [key in keyof Required<FillSymbolizer>]?: SupportDef\n    };\n    MarkSymbolizer?: SupportDef | {\n      [key in keyof Required<MarkSymbolizer>]?: SupportDef\n    };\n    IconSymbolizer?: SupportDef | {\n      [key in keyof Required<IconSymbolizer>]?: SupportDef\n    };\n    TextSymbolizer?: SupportDef | {\n      [key in keyof Required<TextSymbolizer>]?: SupportDef\n    };\n    RasterSymbolizer?: SupportDef | {\n      [key in keyof Required<RasterSymbolizer>]?: SupportDef\n    };\n  };\n  Function?: SupportDef | {\n    [key in GeoStylerFunction['name']]?: SupportDef;\n  };\n}\n\n/**\n * Level of support for a functionality.\n */\nexport type SupportLevel = 'partial' | 'none';\n\n/**\n * Detailed information about the support of a functionality.\n * Can contain an info text.\n */\nexport type SupportInfo = {\n  support: SupportLevel;\n  info?: string;\n};\n\n/**\n * Defines in which way a functionality is supported.\n */\nexport type SupportDef = SupportInfo | SupportLevel;\n\n/**\n * The Result of the readStyle function of a StyleParser.\n */\nexport type ReadStyleResult = {\n  /**\n   * A list of warnings occured while reading the stlye.\n   */\n  warnings?: string[];\n  /**\n   * A list of unsupportedProperties used while reading the style.\n   */\n  unsupportedProperties?: UnsupportedProperties;\n  /**\n   * The geostyler-style as read by the parser.\n   */\n  output?: Style;\n  /**\n   * A list of errors occured while reading the style.\n   */\n  errors?: Error[];\n};\n\n/**\n * The Result of the writeStyle function of a StyleParser.\n */\nexport type WriteStyleResult<T = any> = {\n  /**\n   * A list of warnings occured while writing the style.\n   */\n  warnings?: string[];\n  /**\n   * A list of unsupportedProperties used while writing the style.\n   */\n  unsupportedProperties?: UnsupportedProperties;\n  /**\n   * The target-style as written by the parser.\n   */\n  output?: T;\n  /**\n   * A list of errors occured while writing the style.\n   */\n  errors?: Error[];\n};\n\n/**\n * Interface, which has to be implemented by all GeoStyler style parser classes.\n */\nexport interface StyleParser<T = any> {\n  /**\n   * The name of the Parser\n   */\n  title: string;\n\n  /**\n   * Object specifying which properties are not or just partially supported.\n   */\n  unsupportedProperties?: UnsupportedProperties;\n\n  /**\n   * Parses the inputStyle and transforms it to the GeoStyler Style\n   *\n   * @param inputStyle\n   */\n  readStyle(inputStyle: T): Promise<ReadStyleResult>;\n\n  /**\n   * Reads the GeoStyler Style and transforms it to the target Style\n   * representation.\n   *\n   * @param geoStylerStyle Style\n   */\n  writeStyle(geoStylerStyle: Style): Promise<WriteStyleResult<T>>;\n\n  /**\n   * Parses an input Rule and transforms it to a GeoStyler Rule\n   *\n   * @param inputRule\n   */\n  readRule?(inputRule: any): Promise<Rule>;\n\n  /**\n   * Reads a GeoStyler Rule and transforms it to a target Rule\n   * representation.\n   *\n   * @param geoStylerRule Rule\n   */\n  writeRule?(geoStylerRule: Rule): Promise<any>;\n\n  /**\n   * Parses an input Filter and transforms it to a GeoStyler Filter\n   *\n   * @param inputFilter\n   */\n  readFilter?(inputFilter: any): Promise<Filter>;\n\n  /**\n   * Reads a GeoStyler Filter and transforms it to a target Filter\n   * representation.\n   *\n   * @param geoStylerFilter Filter\n   */\n  writeFilter?(geoStylerFilter: Filter): Promise<any>;\n\n  /**\n   * Parses an input ScaleDenominator and transforms it to a GeoStyler\n   * ScaleDenominator\n   *\n   * @param inputScaleDenominator\n   */\n  readScaleDenominator?(inputScaleDenominator: any): Promise<ScaleDenominator>;\n\n  /**\n   * Reads a GeoStyler ScaleDenominator and transforms it to a target\n   * ScaleDenominator representation\n   *\n   * @param geoStylerScaleDenominator ScaleDenominator\n   */\n  writeScaleDenominator?(geoStylerScaleDenominator: ScaleDenominator): Promise<any>;\n\n  /**\n   * Parses an input Symbolizer and transforms it to a GeoStyler Symbolizer\n   *\n   * @param inputSymbolizer\n   */\n  readSymbolizer?(inputSymbolizer: any): Promise<Symbolizer>;\n\n  /**\n   * Reads a GeoStyler Symbolizer and transforms it to a target Symbolizer\n   * representation\n   *\n   * @param geoStylerSymbolizer Symbolizer\n   */\n  writeSymbolizer?(geoStylerSymbolizer: Symbolizer): Promise<any>;\n}\n"]}