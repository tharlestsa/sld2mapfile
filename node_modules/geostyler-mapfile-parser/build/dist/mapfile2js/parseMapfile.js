"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSymbolset = exports.parseMapfile = void 0;
var checkComment_1 = require("./parse/checkComment");
var checkKeyValue_1 = require("./parse/checkKeyValue");
var checkBlockKey_1 = require("./parse/checkBlockKey");
var parseBlockKey_1 = require("./parse/parseBlockKey");
var checkBlockEndSum_1 = require("./parse/checkBlockEndSum");
var determineDepth_1 = require("./parse/determineDepth");
var resolveSymbolset_1 = require("./parse/resolveSymbolset");
var Logger_1 = __importDefault(require("@terrestris/base-util/dist/Logger"));
// some blocks are actually a key value pair
var pseudoBlockKeys = ['projection', 'pattern', 'points'];
// some keys are reused to specify an array of values
var listKeys = ['formatoption', 'include', 'processing'];
/**
 * Parses a Mapfile line into a JavaScript object.
 * @param {string} line Content of a Mapfile
 * @returns {object} the parsed object
 */
function parseLine(line) {
    var lineObject = { content: line };
    // check included comments
    lineObject = Object.assign(lineObject, (0, checkComment_1.checkComment)(lineObject));
    // check key value
    lineObject = Object.assign(lineObject, (0, checkKeyValue_1.checkKeyValue)(lineObject));
    // check block key
    lineObject = Object.assign(lineObject, (0, checkBlockKey_1.checkBlockKey)(lineObject));
    return lineObject;
}
/**
 * Parses the Mapfile content into a JavaScript object.
 * @param {string} content Content of a Mapfile
 * @returns {object} the parsed object
 */
function parseContent(content) {
    var result = {};
    var lineObjects = [];
    // stack to keep track of blocks
    var blocks = [result];
    var pseudoBlockKey;
    // remove DATA block from full content data
    content = content.replace(/DATA "[^"\\]*(?:\\.[^"\\]*?)*"(\r\n?|\n)/gs, '');
    // split content into trimmed lines like Van Damme
    var lines = content.split(/\s*(?:\r\n?|\n)\s*/g);
    // iterate over lines
    lines.forEach(function (line, index) {
        // ommit empty lines and comments
        if (line === '' || line.startsWith('#')) {
            return;
        }
        // line object
        var lineObject = parseLine(line);
        // store lineobjects
        lineObjects.push(lineObject);
        // current block
        var currentBlock = blocks[blocks.length - 1];
        // handle pseudo blocks
        if (pseudoBlockKeys.includes(lineObject.key)) {
            if (lineObject.value) {
                currentBlock[lineObject.key] = lineObject.value.replace(/\s*END$/i, '');
                if (lineObject.value.match(/\s*END$/i)) {
                    return;
                }
            }
            pseudoBlockKey = lineObject.key;
            return;
        }
        if (pseudoBlockKey && lineObject.key !== 'end') {
            var value = lineObject.contentWithoutComment.replace(/"/g, '');
            if (currentBlock[pseudoBlockKey]) {
                currentBlock[pseudoBlockKey] = currentBlock[pseudoBlockKey] + " " + value;
            }
            else {
                currentBlock[pseudoBlockKey] = value;
            }
            return;
        }
        // handle block & list keys
        if (lineObject.isBlockKey || listKeys.includes(lineObject.key)) {
            var newBlock = (0, parseBlockKey_1.parseBlockKey)(lineObject, currentBlock);
            if (newBlock) {
                blocks.push(newBlock);
            }
            return;
        }
        // handle block end
        if (lineObject.key === 'end') {
            if (pseudoBlockKey) {
                pseudoBlockKey = undefined;
            }
            else {
                blocks.pop();
            }
            return;
        }
        // insert key value pair
        if (lineObject.key in currentBlock) {
            Logger_1.default.warn("Duplicate key on line [" + (index + 1) + "]: " + lineObject.content);
            Logger_1.default.error('Overwriting existing key! consider an array!');
        }
        currentBlock[lineObject.key] = lineObject.value;
    });
    // basic syntax checks
    (0, checkBlockEndSum_1.checkBlockEndSum)(lineObjects);
    (0, determineDepth_1.determineDepth)(lineObjects);
    return result;
}
/**
 * Parses a MapServer Mapfile to a JavaScript object.
 * @param {string} content Content of a MapServer Mapfile
 * @param {string} symbolsPath path of the symbols.sym file if no symbolset is defined in the Mapfile.
 * @returns {Mapfile} the parsed Mapfile
 */
function parseMapfile(content, symbolsPath) {
    var result = parseContent(content);
    // add map bock for consistency if not exists
    result = 'map' in result ? result : { map: result };
    // resolve symbolset
    var mapfile = (0, resolveSymbolset_1.resolveSymbolset)(result, symbolsPath);
    return mapfile;
}
exports.parseMapfile = parseMapfile;
/**
 * Parses a MapServer Symbolsetfile to a JavaScript object.
 * @param {string} content Content of a MapServer Mapfile
 * @returns {MapfileSymbolset} the parsed Symbolset
 */
function parseSymbolset(content) {
    var result = parseContent(content);
    // A Mapfile symbolset begins with SYMBOLSET and ends with END
    if (!('symbolset' in result)) {
        Logger_1.default.error('Symbolset could not be parsed.');
    }
    return result.symbolset;
}
exports.parseSymbolset = parseSymbolset;
//# sourceMappingURL=parseMapfile.js.map