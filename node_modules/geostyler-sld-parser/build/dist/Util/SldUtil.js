"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keysByValue = exports.get = exports.isSymbolizer = exports.getAttribute = exports.getParameterValue = exports.getChild = exports.getChildren = exports.sldFunctionToGeoStylerFunction = exports.geoStylerFunctionToSldFunction = exports.numberExpression = void 0;
var geostyler_style_1 = require("geostyler-style");
/**
 * Cast to Number if it is not a GeoStylerFunction
 *
 * @param exp The GeoStylerExpression
 * @returns The value casted to a number or the GeoStylerNumberFunction
 */
function numberExpression(exp) {
    return (0, geostyler_style_1.isGeoStylerNumberFunction)(exp) ? exp : Number(exp);
}
exports.numberExpression = numberExpression;
/**
 * This converts a GeoStylerFunction into a fast-xml-parser representation
 * of a sld function.
 *
 * @param geostylerFunction A GeoStylerFunction
 * @returns
 */
function geoStylerFunctionToSldFunction(geostylerFunction) {
    var name = geostylerFunction.name;
    // TODO: Typing of functions without args should be refactored in geostyler-style
    if (name === 'pi' || name === 'random') {
        return [{
                Function: [],
                ':@': {
                    '@_name': name
                }
            }];
    }
    if (name === 'property') {
        return {
            PropertyName: [{
                    '#text': geostylerFunction.args[0]
                }]
        };
    }
    var sldFunctionArgs = geostylerFunction.args.map(function (arg) {
        if ((0, geostyler_style_1.isGeoStylerFunction)(arg)) {
            var argAsFunction = geoStylerFunctionToSldFunction(arg);
            return Array.isArray(argAsFunction) ? argAsFunction[0] : argAsFunction;
        }
        else {
            return {
                Literal: [{
                        '#text': arg
                    }]
            };
        }
    });
    var sldFunctionObj = [{
            Function: sldFunctionArgs,
            ':@': {
                '@_name': name
            }
        }];
    return sldFunctionObj;
}
exports.geoStylerFunctionToSldFunction = geoStylerFunctionToSldFunction;
/**
 * This converts the fast-xml-parser representation of a sld function into
 * a GeoStylerFunction.
 *
 * @param sldFunction An array of objects as created by the fast-xml-parser
 * @returns The GeoStylerFunction
 */
function sldFunctionToGeoStylerFunction(sldFunction) {
    var _a, _b;
    var name = (_b = (_a = sldFunction === null || sldFunction === void 0 ? void 0 : sldFunction[0]) === null || _a === void 0 ? void 0 : _a[':@']) === null || _b === void 0 ? void 0 : _b['@_name'];
    var args = sldFunction === null || sldFunction === void 0 ? void 0 : sldFunction[0].Function.map(function (sldArg) {
        var _a, _b, _c, _d;
        if (sldArg.Function) {
            return sldFunctionToGeoStylerFunction([sldArg]);
        }
        else if (sldArg.PropertyName) {
            return {
                name: 'property',
                args: [(_b = (_a = sldArg === null || sldArg === void 0 ? void 0 : sldArg.PropertyName) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b['#text']]
            };
        }
        else {
            return (_d = (_c = sldArg === null || sldArg === void 0 ? void 0 : sldArg.Literal) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d['#text'];
        }
    });
    var geoStylerFunction = { name: name };
    if (args.length > 0) {
        geoStylerFunction.args = args;
    }
    return geoStylerFunction;
}
exports.sldFunctionToGeoStylerFunction = sldFunctionToGeoStylerFunction;
/**
 * Get all child objects with a given tag name.
 *
 * @param elements An array of objects as created by the fast-xml-parser.
 * @param tagName The tagname to get.
 * @returns An array of objects as created by the fast-xml-parser.
 */
function getChildren(elements, tagName) {
    return elements === null || elements === void 0 ? void 0 : elements.filter(function (obj) { return Object.keys(obj).includes(tagName); });
}
exports.getChildren = getChildren;
/**
 * Get the child object with a given tag name.
 *
 * @param elements An array of objects as created by the fast-xml-parser.
 * @param tagName The tagname to get.
 * @returns An object as created by the fast-xml-parser.
 */
function getChild(elements, tagName) {
    return elements === null || elements === void 0 ? void 0 : elements.find(function (obj) { return Object.keys(obj).includes(tagName); });
}
exports.getChild = getChild;
/**
 * Get the value of a Css-/SvgParameter.
 *
 * @param elements An array of objects as created by the fast-xml-parser.
 * @param parameter The parameter name to get.
 * @param sldVersion The sldVersion to distinguish if CssParameter or SvgParameter is used.
 * @returns The string value of the searched parameter.
 */
function getParameterValue(elements, parameter, sldVersion) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (!elements) {
        return undefined;
    }
    var paramKey = sldVersion === '1.0.0' ? 'CssParameter' : 'SvgParameter';
    var element = elements
        .filter(function (obj) { var _a; return (_a = Object.keys(obj)) === null || _a === void 0 ? void 0 : _a.includes(paramKey); })
        .find(function (obj) { var _a; return ((_a = obj === null || obj === void 0 ? void 0 : obj[':@']) === null || _a === void 0 ? void 0 : _a['@_name']) === parameter; });
    // we expected a value but received an array so we check if we have a function
    if ((_b = (_a = element === null || element === void 0 ? void 0 : element[paramKey]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.Function) {
        return sldFunctionToGeoStylerFunction(element === null || element === void 0 ? void 0 : element[paramKey]);
    }
    // … or a Literal
    if ((_d = (_c = element === null || element === void 0 ? void 0 : element[paramKey]) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.Literal) {
        return (_h = (_g = (_f = (_e = element === null || element === void 0 ? void 0 : element[paramKey]) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.Literal) === null || _g === void 0 ? void 0 : _g[0]) === null || _h === void 0 ? void 0 : _h['#text'];
    }
    return (_k = (_j = element === null || element === void 0 ? void 0 : element[paramKey]) === null || _j === void 0 ? void 0 : _j[0]) === null || _k === void 0 ? void 0 : _k['#text'];
}
exports.getParameterValue = getParameterValue;
/**
 * Get the attribute value of an object.
 *
 * @param obj The object to check.
 * @param name The name of the attribute
 * @returns The value of the requested parameter (if available)
 */
function getAttribute(obj, name) {
    var _a;
    return (_a = obj === null || obj === void 0 ? void 0 : obj[':@']) === null || _a === void 0 ? void 0 : _a["@_".concat(name)];
}
exports.getAttribute = getAttribute;
/**
 * Determine if a fast-xml-parser object is a symbolizer representation.
 *
 * @param obj The object to check.
 * @returns Whether the passed object is a symbolizer representation or not.
 */
function isSymbolizer(obj) {
    return Object.keys(obj).some(function (key) { return key.endsWith('Symbolizer'); });
}
exports.isSymbolizer = isSymbolizer;
/**
 * Generic get function which tries to get the nested value of the given object or array.
 * It contains some SLD specific handling and tries to be smart but keep the syntax easy.
 * It always takes the first child of an array if no index was specified in the path argument.
 * e.g.
 *   Get text value: get(sldSymbolizer, 'Graphic.Mark.WellKnownName.#text')
 *   Get an attribute value: get(sldSymbolizer, 'Graphic.ExternalGraphic.OnlineResource.@xlink:href')
 *   Get an Css-/SvgParameter value: get(sldSymbolizer, 'Graphic.Mark.Fill.$fill-opacity', '1.1.0')
 *   Use with an index: get(sldObject, 'StyledLayerDescriptor.NamedLayer[1].UserStyle.Title.#text')
 *
 * @param obj A part of the parser result of the fast-xml-parser.
 * @param path The path to get the value from.
 * @param sldVersion The SLD version to use.
 * @returns
 */
function get(obj, path, sldVersion) {
    var _a, _b, _c, _d, _e, _f;
    var parts = path.split(/\.(.*)/s);
    var key = parts[0];
    var rest = parts[1];
    var target = obj;
    var index = 0;
    // handle queries for attributes
    if (rest === null || rest === void 0 ? void 0 : rest.startsWith('@')) {
        target = getChildren(obj, key)[index];
        return getAttribute(target, rest.substring(1));
    }
    if (Array.isArray(obj)) {
        // we expected a value
        if (key === '#text') {
            // … so we check if we have a function
            if ((_a = target[0]) === null || _a === void 0 ? void 0 : _a.Function) {
                return sldFunctionToGeoStylerFunction(target);
            }
            // … or a Literal
            if ((_b = target[0]) === null || _b === void 0 ? void 0 : _b.Literal) {
                return (_e = (_d = (_c = target[0]) === null || _c === void 0 ? void 0 : _c.Literal) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e['#text'];
            }
        }
        // we expected a value but received an array so we check if we have a function
        if (key === '#text' && ((_f = target[0]) === null || _f === void 0 ? void 0 : _f.Function)) {
            return sldFunctionToGeoStylerFunction(target);
        }
        // handle queries for CssParameter/SvgParameter
        if (key.startsWith('$') && sldVersion) {
            return getParameterValue(target, key.substring(1), sldVersion);
        }
        // handle queries with specified indexes
        if (key.endsWith(']')) {
            index = Number(key.split('[')[1].split(']')[0]);
            key = key.split('[')[0];
        }
        target = getChildren(obj, key)[index];
    }
    if (!target) {
        return undefined;
    }
    if (rest) {
        return get(target[key], rest, sldVersion);
    }
    return target[key];
}
exports.get = get;
/**
 * Returns the keys of an object where the value is equal to the passed in
 * value.
 *
 * @param object The object to get the key from.
 * @param value The value to get the matching key from.
 * @return The matching keys.
 */
function keysByValue(object, value) {
    return Object.keys(object).filter(function (key) { return object[key] === value; });
}
exports.keysByValue = keysByValue;
//# sourceMappingURL=SldUtil.js.map