"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SldStyleParser = void 0;
var geostyler_style_1 = require("geostyler-style");
var fast_xml_parser_1 = require("fast-xml-parser");
var SldUtil_1 = require("./Util/SldUtil");
var WELLKNOWNNAME_TTF_REGEXP = /^ttf:\/\/(.+)#(.+)$/;
/**
 * This parser can be used with the GeoStyler.
 * It implements the geostyler-style StyleParser interface.
 *
 * @class SldStyleParser
 * @implements StyleParser
 */
var SldStyleParser = /** @class */ (function () {
    function SldStyleParser(opts) {
        this.title = 'SLD Style Parser';
        this.unsupportedProperties = {
            Symbolizer: {
                MarkSymbolizer: {
                    avoidEdges: 'none',
                    blur: 'none',
                    offset: 'none',
                    offsetAnchor: 'none',
                    pitchAlignment: 'none',
                    pitchScale: 'none',
                    visibility: 'none'
                },
                FillSymbolizer: {
                    antialias: 'none',
                    opacity: {
                        support: 'none',
                        info: 'General opacity is not supported. Use fillOpacity and strokeOpacity instead.'
                    },
                    visibility: 'none'
                },
                IconSymbolizer: {
                    allowOverlap: 'none',
                    anchor: 'none',
                    avoidEdges: 'none',
                    color: 'none',
                    haloBlur: 'none',
                    haloColor: 'none',
                    haloOpacity: 'none',
                    haloWidth: 'none',
                    keepUpright: 'none',
                    offset: 'none',
                    offsetAnchor: 'none',
                    optional: 'none',
                    padding: 'none',
                    pitchAlignment: 'none',
                    rotationAlignment: 'none',
                    textFit: 'none',
                    textFitPadding: 'none',
                    visibility: 'none'
                },
                LineSymbolizer: {
                    blur: 'none',
                    gapWidth: 'none',
                    gradient: 'none',
                    miterLimit: 'none',
                    roundLimit: 'none',
                    spacing: 'none',
                    visibility: 'none'
                },
                RasterSymbolizer: {
                    brightnessMax: 'none',
                    brightnessMin: 'none',
                    contrast: 'none',
                    fadeDuration: 'none',
                    hueRotate: 'none',
                    resampling: 'none',
                    saturation: 'none',
                    visibility: 'none'
                }
            }
        };
        /**
         * Array of field / property names in a filter, which are casted to numerics
         * while parsing a SLD.
         */
        this._numericFilterFields = [];
        /**
         * Array of field / property names in a filter, which are casted to boolean
         * while parsing a SLD.
         */
        this._boolFilterFields = [];
        /**
         * String indicating the SLD version to use. 1.1.0 will make use of
         * Symbology Encoding. Default ist to use SLD 1.0.0
         */
        this._sldVersion = '1.0.0';
        /**
         * Used to add a `uom` attribute to the symbolizer tag. Can be one of
         * `metre`, `foot` or `pixel`. Defaults to pixel.
         */
        this._symbolizerUnits = 'pixel';
        /**
         * Create a template string from a TextSymbolizer Label element.
         * The ordering of the elemments inside the Label element is preserved.
         *
         * Examples:
         * <Label>
         *  <Literal>foo</Literal>
         *  <PropertyName>bar</PropertyName>
         * </Label>
         * --> "foo{{bar}}"
         *
         * <Label>
         *  <PropertyName>bar</PropertyName>
         *  <Literal>foo</Literal>
         * </Label>
         * --> "{{bar}}foo"
         *
         * <Label>
         *  <PropertyName>bar</PropertyName>
         *  <Literal>foo</Literal>
         *  <PropertyName>john</PropertyName>
         * </Label>
         * --> "{{bar}}foo{{john}}"
         *
         * <Label>
         *  <PropertyName>bar</PropertyName>
         *  <PropertyName>john</PropertyName>
         *  <Literal>foo</Literal>
         * </Label>
         * --> "{{bar}}{{john}}foo"
         *
         * <Label>
         *  <PropertyName>bar</PropertyName>
         *  <PropertyName>john</PropertyName>
         *  <Literal>foo</Literal>
         *  <PropertyName>doe</PropertyName>
         * </Label>
         * --> "{{bar}}{{john}}foo{{doe}}"
         *
         * @param sldLabel
         */
        this.getTextSymbolizerLabelFromSldSymbolizer = function (sldLabel) {
            var label = sldLabel
                .map(function (labelEl) {
                var _a, _b, _c, _d, _e, _f;
                var labelName = Object.keys(labelEl)[0];
                switch (labelName.replace('ogc:', '')) {
                    case '#text':
                        return labelEl['#text'];
                    case 'Literal':
                        return ((_b = (_a = labelEl === null || labelEl === void 0 ? void 0 : labelEl[labelName]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b['#text']) || ((_f = (_e = (_d = (_c = labelEl === null || labelEl === void 0 ? void 0 : labelEl[labelName]) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d['#cdata']) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f['#text']);
                    case 'PropertyName':
                        var propName = labelEl[labelName][0]['#text'];
                        return "{{".concat(propName, "}}");
                    default:
                        return '';
                }
            })
                .join('');
            return label;
        };
        /**
         * Get the Label from a TextSymbolizer
         *
         * @param template The Expression<string> representing the label
         */
        this.getSldLabelFromTextSymbolizer = function (template) {
            // TODO: parse GeoStylerFunction
            if (!(typeof template === 'string' || template instanceof String)) {
                return undefined;
            }
            var openingBraces = '{{';
            var closingBraces = '}}';
            var tokens = [];
            var templateReducer = template;
            while (templateReducer.length) {
                var tmpTemplateReducer = templateReducer;
                var tmpPreTemplateLiteral = void 0;
                var openingBracesIdx = tmpTemplateReducer.indexOf(openingBraces);
                if (openingBracesIdx === -1) {
                    if (templateReducer.includes(' ')) {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#cdata': [{
                                            '#text': templateReducer
                                        }]
                                }]
                        });
                    }
                    else {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#text': templateReducer
                                }]
                        });
                    }
                    break;
                }
                if (openingBracesIdx > 0) {
                    tmpPreTemplateLiteral = tmpTemplateReducer.slice(0, openingBracesIdx);
                }
                tmpTemplateReducer = tmpTemplateReducer.slice(openingBracesIdx + openingBraces.length);
                var closingBracesIdx = tmpTemplateReducer.indexOf(closingBraces);
                if (closingBracesIdx === -1) {
                    if (templateReducer.includes(' ')) {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#cdata': [{
                                            '#text': templateReducer
                                        }]
                                }]
                        });
                    }
                    else {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#text': templateReducer
                                }]
                        });
                    }
                    break;
                }
                var propertyName = tmpTemplateReducer.slice(0, closingBracesIdx);
                tmpTemplateReducer = tmpTemplateReducer.slice(closingBracesIdx + closingBraces.length);
                if (tmpPreTemplateLiteral) {
                    if (tmpPreTemplateLiteral.includes(' ')) {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#cdata': [{
                                            '#text': tmpPreTemplateLiteral
                                        }]
                                }]
                        });
                    }
                    else {
                        tokens.push({
                            'ogc:Literal': [{
                                    '#text': tmpPreTemplateLiteral
                                }]
                        });
                    }
                }
                tokens.push({
                    'ogc:PropertyName': [{
                            '#text': propertyName
                        }]
                });
                templateReducer = tmpTemplateReducer;
            }
            return tokens;
        };
        this.parser = new fast_xml_parser_1.XMLParser(__assign(__assign({}, opts === null || opts === void 0 ? void 0 : opts.parserOptions), { 
            // Fixed attributes
            cdataPropName: '#cdata', ignoreDeclaration: true, removeNSPrefix: true, ignoreAttributes: false, preserveOrder: true }));
        this.builder = new fast_xml_parser_1.XMLBuilder(__assign(__assign({}, opts === null || opts === void 0 ? void 0 : opts.builderOptions), { 
            // Fixed attributes
            cdataPropName: '#cdata', ignoreAttributes: false, suppressEmptyNode: true, preserveOrder: true }));
        if (opts === null || opts === void 0 ? void 0 : opts.sldVersion) {
            this.sldVersion = opts === null || opts === void 0 ? void 0 : opts.sldVersion;
        }
        Object.assign(this, opts);
    }
    Object.defineProperty(SldStyleParser.prototype, "parser", {
        get: function () {
            return this._parser;
        },
        set: function (parser) {
            this._parser = parser;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SldStyleParser.prototype, "builder", {
        get: function () {
            return this._builder;
        },
        set: function (builder) {
            this._builder = builder;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SldStyleParser.prototype, "numericFilterFields", {
        /**
         * Getter for _numericFilterFields
         * @return The numericFilterFields
         */
        get: function () {
            return this._numericFilterFields;
        },
        /**
         * Setter for _numericFilterFields
         * @param numericFilterFields The numericFilterFields to set
         */
        set: function (numericFilterFields) {
            this._numericFilterFields = numericFilterFields;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SldStyleParser.prototype, "boolFilterFields", {
        /**
         * Getter for _boolFilterFields
         * @return The boolFilterFields
         */
        get: function () {
            return this._boolFilterFields;
        },
        /**
         * Setter for _boolFilterFields
         * @param boolFilterFields The boolFilterFields to set
         */
        set: function (boolFilterFields) {
            this._boolFilterFields = boolFilterFields;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SldStyleParser.prototype, "sldVersion", {
        /**
         * Getter for _sldVersion
         * @return
         */
        get: function () {
            return this._sldVersion;
        },
        /**
         * Setter for _sldVersion
         * @param sldVersion The _sldVersion value to set
         */
        set: function (sldVersion) {
            this._sldVersion = sldVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SldStyleParser.prototype, "symbolizerUnits", {
        /**
         * Getter for _symbolizerUnits
         * @return {string}
         */
        get: function () {
            return this._symbolizerUnits;
        },
        /**
         * Setter for _symbolizerUnits
         * @param {string} symbolizerUnits The _symbolizerUnits value to set
         */
        set: function (symbolizerUnits) {
            this._symbolizerUnits = symbolizerUnits;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * The readStyle implementation of the geostyler-style StyleParser interface.
     * It reads a SLD as a string and returns a Promise.
     * The Promise itself resolves with an object containing the geostyler-style.
     *
     * @param sldString A SLD as a string.
     * @return The Promise resolving with an object containing the geostyler-style.
     */
    SldStyleParser.prototype.readStyle = function (sldString) {
        var _this = this;
        return new Promise(function (resolve) {
            try {
                var sldObject = _this.parser.parse(sldString);
                var geoStylerStyle = _this.sldObjectToGeoStylerStyle(sldObject);
                resolve({
                    output: geoStylerStyle
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * Get the geostyler-style from a SLD Object (created with fast-xml-parser).
     *
     * @param sldObject The SLD object representation (created with fast-xml-parser)
     * @return The geostyler-style
     */
    SldStyleParser.prototype.sldObjectToGeoStylerStyle = function (sldObject) {
        var rules = this.getRulesFromSldObject(sldObject);
        var name = this.getStyleNameFromSldObject(sldObject);
        return {
            name: name,
            rules: rules
        };
    };
    /**
     * Get the geostyler-style rules from a SLD Object (created with fast-xml-parser).
     *
     * @param sldObject The SLD object representation (created with fast-xml-parser)
     * @return The geostyler-style rules
     */
    SldStyleParser.prototype.getRulesFromSldObject = function (sldObject) {
        var _this = this;
        var layers = (0, SldUtil_1.getChildren)(sldObject[0].StyledLayerDescriptor, 'NamedLayer');
        var rules = [];
        layers.forEach(function (_a) {
            var layer = _a.NamedLayer;
            (0, SldUtil_1.getChildren)(layer, 'UserStyle').forEach(function (_a) {
                var userStyle = _a.UserStyle;
                (0, SldUtil_1.getChildren)(userStyle, 'FeatureTypeStyle').forEach(function (_a) {
                    var featureTypeStyle = _a.FeatureTypeStyle;
                    (0, SldUtil_1.getChildren)(featureTypeStyle, 'Rule').forEach(function (_a) {
                        var sldRule = _a.Rule;
                        var filter = _this.getFilterFromRule(sldRule);
                        var scaleDenominator = _this.getScaleDenominatorFromRule(sldRule);
                        var symbolizers = _this.getSymbolizersFromRule(sldRule);
                        var ruleTitle = (0, SldUtil_1.get)(sldRule, 'Title.#text');
                        var ruleName = (0, SldUtil_1.get)(sldRule, 'Name.#text');
                        var name = ruleTitle !== undefined
                            ? ruleTitle
                            : (ruleName !== undefined ? ruleName : '');
                        var rule = {
                            name: name
                        };
                        if (filter) {
                            rule.filter = filter;
                        }
                        if (scaleDenominator) {
                            rule.scaleDenominator = scaleDenominator;
                        }
                        if (symbolizers) {
                            rule.symbolizers = symbolizers;
                        }
                        rules.push(rule);
                    });
                });
            });
        });
        return rules;
    };
    /**
     * Get the name for the Style from the SLD Object. Returns the Title of the UserStyle
     * if defined or the Name of the NamedLayer if defined or an empty string.
     *
     * @param sldObject The SLD object representation (created with fast-xml-parser)
     * @return The name to be used for the GeoStyler Style Style
     */
    SldStyleParser.prototype.getStyleNameFromSldObject = function (sldObject) {
        var userStyleTitle = (0, SldUtil_1.get)(sldObject, 'StyledLayerDescriptor.NamedLayer[0].UserStyle.Title.#text');
        var namedLayerName = (0, SldUtil_1.get)(sldObject, 'StyledLayerDescriptor.NamedLayer.Name.#text');
        return userStyleTitle ? userStyleTitle
            : namedLayerName ? namedLayerName : '';
    };
    /**
     * Get the geostyler-style Filter from a SLD Rule.
     *
     * Currently only supports one Filter per Rule.
     *
     * @param sldRule The SLD Rule
     * @return The geostyler-style Filter
     */
    SldStyleParser.prototype.getFilterFromRule = function (sldRule) {
        var _a;
        var sldFilter = (0, SldUtil_1.get)(sldRule, 'Filter');
        if (!sldFilter || sldFilter.length === 0) {
            return;
        }
        var operator = (_a = Object.keys(sldFilter[0])) === null || _a === void 0 ? void 0 : _a[0];
        if (!operator) {
            return;
        }
        var filter = this.getFilterFromOperatorAndComparison(operator, sldFilter);
        return filter;
    };
    /**
     * Get the geostyler-style ScaleDenominator from a SLD Rule.
     *
     * @param sldRule The SLD Rule
     * @return The geostyler-style ScaleDenominator
     */
    SldStyleParser.prototype.getScaleDenominatorFromRule = function (sldRule) {
        var scaleDenominator = {};
        var min = (0, SldUtil_1.get)(sldRule, 'MinScaleDenominator.#text');
        if (min) {
            scaleDenominator.min = Number(min);
        }
        var max = (0, SldUtil_1.get)(sldRule, 'MaxScaleDenominator.#text');
        if (max) {
            scaleDenominator.max = Number(max);
        }
        return (scaleDenominator.min || scaleDenominator.max)
            ? scaleDenominator
            : undefined;
    };
    /**
     * Get the geostyler-style Symbolizers from a SLD Rule.
     *
     * @param sldRule The SLD Rule
     * @return The geostyler-style Symbolizer array
     */
    SldStyleParser.prototype.getSymbolizersFromRule = function (sldRule) {
        var _this = this;
        var symbolizers = sldRule
            .filter(SldUtil_1.isSymbolizer)
            .map(function (sldSymbolizer) {
            var sldSymbolizerName = Object.keys(sldSymbolizer)[0];
            switch (sldSymbolizerName) {
                case 'PointSymbolizer':
                    return _this.getPointSymbolizerFromSldSymbolizer(sldSymbolizer.PointSymbolizer);
                case 'LineSymbolizer':
                    return _this.getLineSymbolizerFromSldSymbolizer(sldSymbolizer.LineSymbolizer);
                case 'TextSymbolizer':
                    return _this.getTextSymbolizerFromSldSymbolizer(sldSymbolizer.TextSymbolizer);
                case 'PolygonSymbolizer':
                    return _this.getFillSymbolizerFromSldSymbolizer(sldSymbolizer.PolygonSymbolizer);
                case 'RasterSymbolizer':
                    return _this.getRasterSymbolizerFromSldSymbolizer(sldSymbolizer.RasterSymbolizer);
                default:
                    throw new Error('Failed to parse SymbolizerKind from SldRule');
            }
        });
        return symbolizers;
    };
    /**
     * Creates a geostyler-style Filter from a given operator name and the js
     * SLD object representation (created with fast-xml-parser) of the SLD Filter.
     *
     * @param sldOperatorName The Name of the SLD Filter Operator
     * @param sldFilter The SLD Filter
     * @return The geostyler-style Filter
     */
    SldStyleParser.prototype.getFilterFromOperatorAndComparison = function (sldOperatorName, sldFilter) {
        var _this = this;
        var _a;
        var filter;
        if (sldOperatorName === 'Function') {
            var functionName = sldFilter[0][':@']['@_name'];
            var tempFunctionName = functionName.charAt(0).toUpperCase() + functionName.slice(1);
            sldOperatorName = "PropertyIs".concat(tempFunctionName);
        }
        // we have to first check for PropertyIsBetween,
        // since it is also a comparisonOperator. But it
        // needs to be treated differently.
        if (sldOperatorName === 'PropertyIsBetween') {
            // TODO: PropertyIsBetween spec allows more than just a PropertyName as its first argument.
            var propertyName = (0, SldUtil_1.get)(sldFilter, 'PropertyIsBetween.PropertyName.#text');
            var lower = Number((0, SldUtil_1.get)(sldFilter, 'PropertyIsBetween.LowerBoundary.Literal.#text'));
            var upper = Number((0, SldUtil_1.get)(sldFilter, 'PropertyIsBetween.UpperBoundary.Literal.#text'));
            filter = ['<=x<=', propertyName, lower, upper];
        }
        else if (Object.keys(SldStyleParser.comparisonMap).includes(sldOperatorName)) {
            var comparisonOperator = SldStyleParser.comparisonMap[sldOperatorName];
            var filterIsFunction = !!(0, SldUtil_1.get)(sldFilter, 'Function');
            var args = [];
            var childrenToArgs = function (child) {
                if ((0, SldUtil_1.get)([child], '#text') !== undefined) {
                    return (0, SldUtil_1.get)([child], '#text');
                }
                else {
                    return (0, SldUtil_1.get)([child], 'PropertyName.#text');
                }
            };
            var children = (0, SldUtil_1.get)(sldFilter, filterIsFunction ? 'Function' : sldOperatorName) || [];
            args = children.map(childrenToArgs);
            if (sldOperatorName === 'PropertyIsNull') {
                args[1] = null;
            }
            filter = __spreadArray([
                comparisonOperator
            ], args, true);
        }
        else if (Object.keys(SldStyleParser.combinationMap).includes(sldOperatorName)) {
            var combinationOperator = SldStyleParser.combinationMap[sldOperatorName];
            var filters = (_a = (0, SldUtil_1.get)(sldFilter, sldOperatorName)) === null || _a === void 0 ? void 0 : _a.map(function (op) {
                var _a;
                var operatorName = (_a = Object.keys(op)) === null || _a === void 0 ? void 0 : _a[0];
                return _this.getFilterFromOperatorAndComparison(operatorName, op);
            });
            filter = __spreadArray([
                combinationOperator
            ], filters, true);
        }
        else if (Object.keys(SldStyleParser.negationOperatorMap).includes(sldOperatorName)) {
            var negationOperator = SldStyleParser.negationOperatorMap[sldOperatorName];
            var negatedOperator = Object.keys(sldFilter[sldOperatorName][0])[0];
            var negatedComparison = sldFilter[sldOperatorName][0];
            var negatedFilter = this.getFilterFromOperatorAndComparison(negatedOperator, negatedComparison);
            filter = [
                negationOperator,
                negatedFilter
            ];
        }
        else {
            throw new Error('No Filter detected');
        }
        return filter;
    };
    /**
     * Get the geostyler-style PointSymbolizer from a SLD Symbolizer.
     *
     * The opacity of the Symbolizer is taken from the <Graphic>.
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style PointSymbolizer
     */
    SldStyleParser.prototype.getPointSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var pointSymbolizer;
        var wellKnownName = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Mark.WellKnownName.#text');
        var externalGraphic = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.ExternalGraphic');
        if (externalGraphic) {
            pointSymbolizer = this.getIconSymbolizerFromSldSymbolizer(sldSymbolizer);
        }
        else {
            // geoserver does not set a wellKnownName for square explicitly since it is the default value.
            // Therefore, we have to set the wellKnownName to square if no wellKownName is given.
            if (!wellKnownName) {
                // TODO: Fix this. Idealy without lodash
                // _set(sldSymbolizer, 'Graphic[0].Mark[0].WellKnownName[0]._', 'square');
            }
            pointSymbolizer = this.getMarkSymbolizerFromSldSymbolizer(sldSymbolizer);
        }
        return pointSymbolizer;
    };
    /**
     * Get the geostyler-style LineSymbolizer from a SLD Symbolizer.
     *
     * Currently only the CssParameters are available.
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style LineSymbolizer
     */
    SldStyleParser.prototype.getLineSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var lineSymbolizer = {
            kind: 'Line'
        };
        var strokeEl = (0, SldUtil_1.get)(sldSymbolizer, 'Stroke');
        var color = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke', this.sldVersion);
        var width = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-width', this.sldVersion);
        var opacity = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-opacity', this.sldVersion);
        var lineJoin = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-linejoin', this.sldVersion);
        var lineCap = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-linecap', this.sldVersion);
        var dashArray = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-dasharray', this.sldVersion);
        var dashOffset = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-dashoffset', this.sldVersion);
        if (color) {
            lineSymbolizer.color = color;
        }
        if (width !== undefined) {
            lineSymbolizer.width = (0, SldUtil_1.numberExpression)(width);
        }
        if (opacity !== undefined) {
            lineSymbolizer.opacity = (0, SldUtil_1.numberExpression)(opacity);
        }
        if (lineJoin) {
            // geostyler-style and ol use 'miter' whereas sld uses 'mitre'
            if (lineJoin === 'mitre') {
                lineSymbolizer.join = 'miter';
            }
            else {
                lineSymbolizer.join = lineJoin;
            }
        }
        if (lineCap) {
            lineSymbolizer.cap = lineCap;
        }
        if (dashArray) {
            var dashStringAsArray = dashArray.split(' ').map(SldUtil_1.numberExpression);
            lineSymbolizer.dasharray = dashStringAsArray;
        }
        if (dashOffset) {
            lineSymbolizer.dashOffset = (0, SldUtil_1.numberExpression)(dashOffset);
        }
        var graphicStroke = (0, SldUtil_1.get)(strokeEl, 'GraphicStroke');
        if (graphicStroke !== undefined) {
            lineSymbolizer.graphicStroke = this.getPointSymbolizerFromSldSymbolizer(graphicStroke);
        }
        var graphicFill = (0, SldUtil_1.get)(strokeEl, 'GraphicFill');
        if (graphicFill !== undefined) {
            lineSymbolizer.graphicFill = this.getPointSymbolizerFromSldSymbolizer(graphicFill);
        }
        var perpendicularOffset = (0, SldUtil_1.get)(sldSymbolizer, 'PerpendicularOffset.#text');
        if (perpendicularOffset !== undefined) {
            lineSymbolizer.perpendicularOffset = (0, SldUtil_1.numberExpression)(perpendicularOffset);
        }
        return lineSymbolizer;
    };
    /**
     * Get the geostyler-style TextSymbolizer from a SLD Symbolizer.
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style TextSymbolizer
     */
    SldStyleParser.prototype.getTextSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var textSymbolizer = {
            kind: 'Text'
        };
        var fontEl = (0, SldUtil_1.get)(sldSymbolizer, 'Font');
        var fillEl = (0, SldUtil_1.get)(sldSymbolizer, 'Fill');
        var labelEl = (0, SldUtil_1.get)(sldSymbolizer, 'Label');
        var haloEl = (0, SldUtil_1.get)(sldSymbolizer, 'Halo');
        var haloFillEl = (0, SldUtil_1.get)(haloEl, 'Fill');
        var color = (0, SldUtil_1.getParameterValue)(fillEl, 'fill', this.sldVersion);
        var opacity = (0, SldUtil_1.getParameterValue)(fillEl, 'fill-opacity', this.sldVersion);
        var fontFamily = (0, SldUtil_1.getParameterValue)(fontEl, 'font-family', this.sldVersion);
        var fontStyle = (0, SldUtil_1.getParameterValue)(fontEl, 'font-style', this.sldVersion);
        var fontSize = (0, SldUtil_1.getParameterValue)(fontEl, 'font-size', this.sldVersion);
        var fontWeight = (0, SldUtil_1.getParameterValue)(fontEl, 'font-weight', this.sldVersion);
        var haloColor = (0, SldUtil_1.getParameterValue)(haloFillEl, 'fill', this.sldVersion);
        if (labelEl) {
            textSymbolizer.label = this.getTextSymbolizerLabelFromSldSymbolizer(labelEl);
        }
        textSymbolizer.color = color ? color : '#000000';
        textSymbolizer.opacity = opacity ? (0, SldUtil_1.numberExpression)(opacity) : 1;
        var haloRadius = (0, SldUtil_1.get)(sldSymbolizer, 'Halo.Radius.#text');
        if (haloRadius) {
            textSymbolizer.haloWidth = (0, SldUtil_1.numberExpression)(haloRadius);
        }
        var haloOpacity = (0, SldUtil_1.getParameterValue)(haloFillEl, 'fill-opacity', this.sldVersion);
        if (haloOpacity) {
            textSymbolizer.haloOpacity = (0, SldUtil_1.numberExpression)(haloOpacity);
        }
        if (haloColor) {
            textSymbolizer.haloColor = haloColor;
        }
        var displacement = (0, SldUtil_1.get)(sldSymbolizer, 'LabelPlacement.PointPlacement.Displacement');
        if (displacement) {
            var x = (0, SldUtil_1.get)(displacement, 'DisplacementX.#text');
            var y = (0, SldUtil_1.get)(displacement, 'DisplacementY.#text');
            textSymbolizer.offset = [
                x ? parseFloat(x) : 0,
                y ? parseFloat(y) : 0,
            ];
        }
        var rotation = (0, SldUtil_1.get)(sldSymbolizer, 'LabelPlacement.PointPlacement.Rotation.#text');
        if (rotation) {
            textSymbolizer.rotate = (0, SldUtil_1.numberExpression)(rotation);
        }
        if (fontFamily) {
            textSymbolizer.font = [fontFamily];
        }
        if (fontStyle) {
            textSymbolizer.fontStyle = fontStyle.toLowerCase();
        }
        if (fontWeight) {
            textSymbolizer.fontWeight = fontWeight.toLowerCase();
        }
        if (fontSize) {
            textSymbolizer.size = (0, SldUtil_1.numberExpression)(fontSize);
        }
        return textSymbolizer;
    };
    /**
     * Get the geostyler-style FillSymbolizer from a SLD Symbolizer.
     *
     * PolygonSymbolizer Stroke is just partially supported.
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style FillSymbolizer
     */
    SldStyleParser.prototype.getFillSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var fillSymbolizer = {
            kind: 'Fill'
        };
        var strokeEl = (0, SldUtil_1.get)(sldSymbolizer, 'Stroke');
        var fillEl = (0, SldUtil_1.get)(sldSymbolizer, 'Fill');
        var fillOpacity = (0, SldUtil_1.getParameterValue)(fillEl, 'fill-opacity', this.sldVersion);
        var color = (0, SldUtil_1.getParameterValue)(fillEl, 'fill', this.sldVersion);
        var outlineColor = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke', this.sldVersion);
        var outlineWidth = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-width', this.sldVersion);
        var outlineOpacity = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-opacity', this.sldVersion);
        var outlineDashArray = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-dasharray', this.sldVersion);
        var outlineCap = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-linecap', this.sldVersion);
        var outlineJoin = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-linejoin', this.sldVersion);
        // const outlineDashOffset = getParameterValue(strokeEl, 'stroke-dashoffset', this.sldVersion);
        var graphicFill = (0, SldUtil_1.get)(sldSymbolizer, 'Fill.GraphicFill');
        if (graphicFill) {
            fillSymbolizer.graphicFill = this.getPointSymbolizerFromSldSymbolizer(graphicFill);
        }
        if (color) {
            fillSymbolizer.color = color;
        }
        if (fillOpacity) {
            fillSymbolizer.fillOpacity = (0, SldUtil_1.numberExpression)(fillOpacity);
        }
        if (outlineColor) {
            fillSymbolizer.outlineColor = outlineColor;
        }
        if (outlineWidth) {
            fillSymbolizer.outlineWidth = (0, SldUtil_1.numberExpression)(outlineWidth);
        }
        if (outlineOpacity) {
            fillSymbolizer.outlineOpacity = (0, SldUtil_1.numberExpression)(outlineOpacity);
        }
        if (outlineDashArray) {
            fillSymbolizer.outlineDasharray = outlineDashArray.split(' ').map(SldUtil_1.numberExpression);
        }
        if (outlineCap) {
            fillSymbolizer.outlineCap = outlineCap;
        }
        if (outlineJoin) {
            fillSymbolizer.outlineJoin = outlineJoin;
        }
        // TODO: seems like this is missing in the geostyer-stlye
        // if (outlineDashOffset) {
        //   fillSymbolizer.outlineDashOffset = Number(outlineDashOffset);
        // }
        return fillSymbolizer;
    };
    /**
     * Get the geostyler-style RasterSymbolizer from a SLD Symbolizer.
     *
     * @param sldSymbolizer The SLD Symbolizer
     */
    SldStyleParser.prototype.getRasterSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var rasterSymbolizer = {
            kind: 'Raster'
        };
        // parse Opacity
        var opacity = (0, SldUtil_1.get)(sldSymbolizer, 'Opacity.#text');
        if (opacity) {
            opacity = (0, SldUtil_1.numberExpression)(opacity);
            rasterSymbolizer.opacity = opacity;
        }
        // parse ColorMap
        var sldColorMap = (0, SldUtil_1.get)(sldSymbolizer, 'ColorMap');
        var sldColorMapType = (0, SldUtil_1.get)(sldSymbolizer, 'ColorMap.@type');
        var extended = (0, SldUtil_1.get)(sldSymbolizer, 'ColorMap.@extended');
        if (sldColorMap) {
            var colormap = this.getColorMapFromSldColorMap(sldColorMap, sldColorMapType, extended);
            rasterSymbolizer.colorMap = colormap;
        }
        // parse ChannelSelection
        var sldChannelSelection = (0, SldUtil_1.get)(sldSymbolizer, 'ChannelSelection');
        if (sldChannelSelection) {
            var channelSelection = this.getChannelSelectionFromSldChannelSelection(sldChannelSelection);
            rasterSymbolizer.channelSelection = channelSelection;
        }
        // parse ContrastEnhancement
        var sldContrastEnhancement = (0, SldUtil_1.get)(sldSymbolizer, 'ContrastEnhancement');
        if (sldContrastEnhancement) {
            var contrastEnhancement = this.getContrastEnhancementFromSldContrastEnhancement(sldContrastEnhancement);
            rasterSymbolizer.contrastEnhancement = contrastEnhancement;
        }
        return rasterSymbolizer;
    };
    /**
     * Get the geostyler-style MarkSymbolizer from a SLD Symbolizer
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style MarkSymbolizer
     */
    SldStyleParser.prototype.getMarkSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var wellKnownName = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Mark.WellKnownName.#text');
        var strokeEl = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Mark.Stroke');
        var fillEl = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Mark.Fill');
        var opacity = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Opacity.#text');
        var size = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Size.#text');
        var rotation = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Rotation.#text');
        var fillOpacity = (0, SldUtil_1.getParameterValue)(fillEl, 'fill-opacity', this.sldVersion);
        var color = (0, SldUtil_1.getParameterValue)(fillEl, 'fill', this.sldVersion);
        var markSymbolizer = {
            kind: 'Mark',
            wellKnownName: 'circle'
        };
        if (opacity) {
            markSymbolizer.opacity = (0, SldUtil_1.numberExpression)(opacity);
        }
        if (fillOpacity) {
            markSymbolizer.fillOpacity = (0, SldUtil_1.numberExpression)(fillOpacity);
        }
        if (color) {
            markSymbolizer.color = color;
        }
        if (rotation) {
            markSymbolizer.rotate = (0, SldUtil_1.numberExpression)(rotation);
        }
        if (size) {
            // edge case where the value has to be divided by 2 which has to be considered in the function
            markSymbolizer.radius = (0, geostyler_style_1.isGeoStylerNumberFunction)(size) ? size : Number(size) / 2;
        }
        switch (wellKnownName) {
            case 'circle':
            case 'square':
            case 'triangle':
            case 'star':
            case 'cross':
            case 'x':
            case 'shape://vertline':
            case 'shape://horline':
            case 'shape://slash':
            case 'shape://backslash':
            case 'shape://dot':
            case 'shape://plus':
            case 'shape://times':
            case 'shape://oarrow':
            case 'shape://carrow':
                markSymbolizer.wellKnownName = wellKnownName;
                break;
            default:
                if (WELLKNOWNNAME_TTF_REGEXP.test(wellKnownName)) {
                    markSymbolizer.wellKnownName = wellKnownName;
                    break;
                }
                throw new Error('MarkSymbolizer cannot be parsed. Unsupported WellKnownName.');
        }
        var strokeColor = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke', this.sldVersion);
        if (strokeColor) {
            markSymbolizer.strokeColor = strokeColor;
        }
        var strokeWidth = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-width', this.sldVersion);
        if (strokeWidth) {
            markSymbolizer.strokeWidth = (0, SldUtil_1.numberExpression)(strokeWidth);
        }
        var strokeOpacity = (0, SldUtil_1.getParameterValue)(strokeEl, 'stroke-opacity', this.sldVersion);
        if (strokeOpacity) {
            markSymbolizer.strokeOpacity = (0, SldUtil_1.numberExpression)(strokeOpacity);
        }
        return markSymbolizer;
    };
    /**
     * Get the geostyler-style IconSymbolizer from a SLD Symbolizer
     *
     * @param sldSymbolizer The SLD Symbolizer
     * @return The geostyler-style IconSymbolizer
     */
    SldStyleParser.prototype.getIconSymbolizerFromSldSymbolizer = function (sldSymbolizer) {
        var image = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.ExternalGraphic.OnlineResource.@href');
        var iconSymbolizer = {
            kind: 'Icon',
            image: image
        };
        var opacity = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Opacity.#text');
        var size = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Size.#text');
        var rotation = (0, SldUtil_1.get)(sldSymbolizer, 'Graphic.Rotation.#text');
        if (opacity) {
            iconSymbolizer.opacity = (0, SldUtil_1.numberExpression)(opacity);
        }
        if (size) {
            iconSymbolizer.size = (0, SldUtil_1.numberExpression)(size);
        }
        if (rotation) {
            iconSymbolizer.rotate = (0, SldUtil_1.numberExpression)(rotation);
        }
        return iconSymbolizer;
    };
    /**
     * Get the geostyler-style ColorMap from a SLD ColorMap.
     *
     * @param sldColorMap The SLD ColorMap
     */
    SldStyleParser.prototype.getColorMapFromSldColorMap = function (sldColorMap, type, extended) {
        if (type === void 0) { type = 'ramp'; }
        var colorMap = {
            type: type
        };
        if (extended) {
            if (extended === 'true') {
                colorMap.extended = true;
            }
            else {
                colorMap.extended = false;
            }
        }
        var colorMapEntries = (0, SldUtil_1.getChildren)(sldColorMap, 'ColorMapEntry');
        if (Array.isArray(colorMapEntries)) {
            var cmEntries = colorMapEntries.map(function (cm) {
                var color = (0, SldUtil_1.getAttribute)(cm, 'color');
                if (!color) {
                    throw new Error('Cannot parse ColorMapEntries. color is undefined.');
                }
                var quantity = (0, SldUtil_1.getAttribute)(cm, 'quantity');
                if (quantity) {
                    quantity = (0, SldUtil_1.numberExpression)(quantity);
                }
                var label = (0, SldUtil_1.getAttribute)(cm, 'label');
                var opacity = (0, SldUtil_1.getAttribute)(cm, 'opacity');
                if (opacity) {
                    opacity = (0, SldUtil_1.numberExpression)(opacity);
                }
                return {
                    color: color,
                    quantity: quantity,
                    label: label,
                    opacity: opacity
                };
            });
            colorMap.colorMapEntries = cmEntries;
        }
        return colorMap;
    };
    /**
     * Get the geostyler-style ContrastEnhancement from a SLD ContrastEnhancement.
     *
     * @param sldContrastEnhancement The SLD ContrastEnhancement
     */
    SldStyleParser.prototype.getContrastEnhancementFromSldContrastEnhancement = function (sldContrastEnhancement) {
        var contrastEnhancement = {};
        // parse enhancementType
        var hasHistogram = !!(0, SldUtil_1.get)(sldContrastEnhancement, 'Histogram');
        var hasNormalize = !!(0, SldUtil_1.get)(sldContrastEnhancement, 'Normalize');
        if (hasHistogram && hasNormalize) {
            throw new Error("Cannot parse ContrastEnhancement. Histogram and Normalize\n        are mutually exclusive.");
        }
        else if (hasHistogram) {
            contrastEnhancement.enhancementType = 'histogram';
        }
        else if (hasNormalize) {
            contrastEnhancement.enhancementType = 'normalize';
        }
        // parse gammavalue
        var gammaValue = (0, SldUtil_1.get)(sldContrastEnhancement, 'GammaValue.#text');
        if (gammaValue) {
            gammaValue = (0, SldUtil_1.numberExpression)(gammaValue);
        }
        contrastEnhancement.gammaValue = gammaValue;
        return contrastEnhancement;
    };
    /**
     * Get the geostyler-style Channel from a SLD Channel.
     *
     * @param sldChannel The SLD Channel
     */
    SldStyleParser.prototype.getChannelFromSldChannel = function (sldChannel) {
        var _a;
        var sourceChannelName = (_a = (0, SldUtil_1.get)(sldChannel, 'SourceChannelName.#text')) === null || _a === void 0 ? void 0 : _a.toString();
        var channel = {
            sourceChannelName: sourceChannelName
        };
        var contrastEnhancement = (0, SldUtil_1.get)(sldChannel, 'ContrastEnhancement');
        if (contrastEnhancement) {
            channel.contrastEnhancement = this.getContrastEnhancementFromSldContrastEnhancement(contrastEnhancement);
        }
        return channel;
    };
    /**
     * Get the geostyler-style ChannelSelection from a SLD ChannelSelection.
     *
     * @param sldChannelSelection The SLD ChannelSelection
     */
    SldStyleParser.prototype.getChannelSelectionFromSldChannelSelection = function (sldChannelSelection) {
        var channelSelection;
        var red = (0, SldUtil_1.get)(sldChannelSelection, 'RedChannel');
        var blue = (0, SldUtil_1.get)(sldChannelSelection, 'BlueChannel');
        var green = (0, SldUtil_1.get)(sldChannelSelection, 'GreenChannel');
        var gray = (0, SldUtil_1.get)(sldChannelSelection, 'GrayChannel');
        if (gray && red && blue && green) {
            throw new Error('Cannot parse ChannelSelection. RGB and Grayscale are mutually exclusive');
        }
        if (gray) {
            var grayChannel = this.getChannelFromSldChannel(gray);
            channelSelection = {
                grayChannel: grayChannel
            };
        }
        else if (red && green && blue) {
            var redChannel = this.getChannelFromSldChannel(red);
            var blueChannel = this.getChannelFromSldChannel(blue);
            var greenChannel = this.getChannelFromSldChannel(green);
            channelSelection = {
                redChannel: redChannel,
                blueChannel: blueChannel,
                greenChannel: greenChannel
            };
        }
        else {
            throw new Error('Cannot parse ChannelSelection. Red, Green and Blue channels must be defined.');
        }
        return channelSelection;
    };
    /**
     * The writeStyle implementation of the geostyler-style StyleParser interface.
     * It reads a geostyler-style and returns a Promise.
     * The Promise itself resolves with a SLD string.
     *
     * @param geoStylerStyle A geostyler-style.
     * @return The Promise resolving with the SLD as a string.
     */
    SldStyleParser.prototype.writeStyle = function (geoStylerStyle) {
        var _this = this;
        return new Promise(function (resolve) {
            var unsupportedProperties = _this.checkForUnsupportedProperites(geoStylerStyle);
            try {
                var sldObject = _this.geoStylerStyleToSldObject(geoStylerStyle);
                var sldString = _this.builder.build(sldObject);
                resolve({
                    output: sldString,
                    unsupportedProperties: unsupportedProperties,
                    warnings: unsupportedProperties && ['Your style contains unsupportedProperties!']
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * Get the correct tagName in dependency to the configured sldVersion.
     *
     * @param tagName
     * @returns The tagName as used by the configured sldVersion
     */
    SldStyleParser.prototype.getTagName = function (tagName) {
        var ogcList = ['Filter'];
        if (ogcList.includes(tagName)) {
            return this.sldVersion === '1.1.0' ? "ogc:".concat(tagName) : tagName;
        }
        if (tagName === 'CssParameter') {
            return this.sldVersion === '1.1.0' ? 'se:SvgParameter' : 'CssParameter';
        }
        return this.sldVersion === '1.1.0' ? "se:".concat(tagName) : tagName;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style
     *
     * @param geoStylerStyle A geostyler-style.
     * @return The object representation of a SLD Style (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.geoStylerStyleToSldObject = function (geoStylerStyle) {
        var _a, _b, _c, _d;
        var rules = this.getSldRulesFromRules(geoStylerStyle.rules);
        // add the ogc namespace to the filter element, if a filter is present
        rules.forEach(function (rule) {
            if (rule.Filter && !rule.Filter['@_xmlns']) {
                rule.Filter['@_xmlns'] = 'http://www.opengis.net/ogc';
            }
        });
        var featureTypeStyle = __spreadArray([], rules, true);
        var Name = this.getTagName('Name');
        var Title = this.getTagName('Title');
        var FeatureTypeStyle = this.getTagName('FeatureTypeStyle');
        var attributes = {
            '@_version': this.sldVersion,
            '@_xsi:schemaLocation': 'http://www.opengis.net/sld StyledLayerDescriptor.xsd',
            '@_xmlns': 'http://www.opengis.net/sld',
            '@_xmlns:ogc': 'http://www.opengis.net/ogc',
            '@_xmlns:xlink': 'http://www.w3.org/1999/xlink',
            '@_xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'
        };
        if (this.sldVersion === '1.1.0') {
            attributes['@_xmlns:se'] = 'http://www.opengis.net/se';
        }
        return [{
                '?xml': [{ '#text': '' }],
                ':@': {
                    '@_version': '1.0',
                    '@_encoding': 'UTF-8',
                    '@_standalone': 'yes'
                },
            }, {
                StyledLayerDescriptor: [{
                        NamedLayer: [(_a = {},
                                _a[Name] = [{ '#text': geoStylerStyle.name || '' }],
                                _a), {
                                UserStyle: [(_b = {},
                                        _b[Name] = [{ '#text': geoStylerStyle.name || '' }],
                                        _b), (_c = {},
                                        _c[Title] = [{ '#text': geoStylerStyle.name || '' }],
                                        _c), (_d = {},
                                        _d[FeatureTypeStyle] = featureTypeStyle,
                                        _d)]
                            }]
                    }],
                ':@': attributes
            }];
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style Rule.
     *
     * @param rules An array of geostyler-style Rules.
     * @return The object representation of a SLD Rule (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldRulesFromRules = function (rules) {
        var _this = this;
        var Name = this.getTagName('Name');
        var Filter = this.getTagName('Filter');
        var Rule = this.getTagName('Rule');
        var MinScaleDenominator = this.getTagName('MinScaleDenominator');
        var MaxScaleDenominator = this.getTagName('MaxScaleDenominator');
        return rules.map(function (rule) {
            var _a, _b, _c, _d, _e;
            var sldRule = (_a = {},
                _a[Rule] = [],
                _a);
            if (rule.name) {
                sldRule[Rule].push((_b = {},
                    _b[Name] = [{
                            '#text': rule.name
                        }],
                    _b));
            }
            if (rule.filter) {
                var filter = _this.getSldFilterFromFilter(rule.filter);
                sldRule[Rule].push((_c = {},
                    _c[Filter] = filter,
                    _c));
            }
            if (rule.scaleDenominator) {
                var _f = rule.scaleDenominator, min = _f.min, max = _f.max;
                if (min && Number.isFinite(min)) {
                    sldRule[Rule].push((_d = {},
                        _d[MinScaleDenominator] = [{
                                '#text': min
                            }],
                        _d));
                }
                if (max && Number.isFinite(max)) {
                    sldRule[Rule].push((_e = {},
                        _e[MaxScaleDenominator] = [{
                                '#text': max
                            }],
                        _e));
                }
            }
            // Remove empty Symbolizers and check if there is at least 1 symbolizer
            var symbolizers = _this.getSldSymbolizersFromSymbolizers(rule.symbolizers);
            var symbolizerKeys = [];
            if (symbolizers.length > 0) {
                symbolizerKeys = Object.keys(symbolizers[0]);
            }
            symbolizerKeys.forEach(function (key) {
                if (symbolizers[0][key].length === 0) {
                    delete symbolizers[0][key];
                }
            });
            if (symbolizers.length > 0 && symbolizerKeys.length !== 0) {
                sldRule[Rule] = __spreadArray(__spreadArray([], sldRule[Rule], true), symbolizers, true);
            }
            return sldRule;
        });
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style ComparisonFilter.
     *
     * @param comparisonFilter A geostyler-style ComparisonFilter.
     * @return The object representation of a SLD Filter Expression with a
     * comparison operator (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldComparisonFilterFromComparisonFilter = function (comparisonFilter) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var sldComparisonFilter = [];
        var operator = comparisonFilter[0];
        var key = comparisonFilter[1];
        var value = comparisonFilter[2];
        var sldOperators = (0, SldUtil_1.keysByValue)(SldStyleParser.comparisonMap, operator);
        var sldOperator = (sldOperators.length > 1 && value === null)
            ? sldOperators[1] : sldOperators[0];
        var propertyKey = 'PropertyName';
        if ((0, geostyler_style_1.isGeoStylerFunction)(key) || (0, geostyler_style_1.isGeoStylerFunction)(value)) {
            var tempOperator = sldOperator.replace('PropertyIs', '');
            var sldFunctionOperator = tempOperator.charAt(0).toLowerCase() + tempOperator.slice(1);
            var keyResult = (0, geostyler_style_1.isGeoStylerFunction)(key) ? (0, SldUtil_1.geoStylerFunctionToSldFunction)(key) : key;
            var valueResult = (0, geostyler_style_1.isGeoStylerFunction)(value) ? (0, SldUtil_1.geoStylerFunctionToSldFunction)(value) : value;
            var functionChildren = [];
            if ((0, geostyler_style_1.isGeoStylerFunction)(key)) {
                functionChildren.unshift(keyResult === null || keyResult === void 0 ? void 0 : keyResult[0]);
            }
            else {
                functionChildren.unshift({
                    Literal: [{
                            '#text': keyResult
                        }]
                });
            }
            if ((0, geostyler_style_1.isGeoStylerFunction)(value)) {
                functionChildren.push(valueResult === null || valueResult === void 0 ? void 0 : valueResult[0]);
            }
            else {
                functionChildren.push({
                    Literal: [{
                            '#text': valueResult
                        }]
                });
            }
            return [{
                    Function: functionChildren,
                    ':@': {
                        '@_name': sldFunctionOperator
                    }
                }];
        }
        if (sldOperator === 'PropertyIsNull') {
            // empty, selfclosing Literals are not valid in a propertyIsNull filter
            sldComparisonFilter.push((_a = {},
                _a[sldOperator] = [(_b = {},
                        _b[propertyKey] = [{
                                '#text': key
                            }],
                        _b)],
                _a));
        }
        else if (sldOperator === 'PropertyIsLike') {
            sldComparisonFilter.push((_c = {},
                _c[sldOperator] = [(_d = {},
                        _d[propertyKey] = [{
                                '#text': key
                            }],
                        _d), {
                        Literal: [{
                                '#text': value
                            }]
                    }],
                _c[':@'] = {
                    '@_wildCard': '*',
                    '@_singleChar': '.',
                    '@_escape': '!',
                },
                _c));
        }
        else if (sldOperator === 'PropertyIsBetween') {
            // Currently we only support Literals as values.
            var betweenFilter = comparisonFilter;
            sldComparisonFilter.push((_e = {},
                _e[sldOperator] = [(_f = {},
                        _f[propertyKey] = [{
                                '#text': key
                            }],
                        _f), {
                        LowerBoundary: [{
                                Literal: [{
                                        '#text': betweenFilter[2]
                                    }]
                            }]
                    }, {
                        UpperBoundary: [{
                                Literal: [{
                                        '#text': betweenFilter[3]
                                    }]
                            }]
                    }],
                _e));
        }
        else {
            sldComparisonFilter.push((_g = {},
                _g[sldOperator] = [(_h = {},
                        _h[propertyKey] = [{
                                '#text': key
                            }],
                        _h), {
                        Literal: [{
                                '#text': value
                            }]
                    }],
                _g));
        }
        return sldComparisonFilter;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style Filter.
     *
     * @param filter A geostyler-style Filter.
     * @return The object representation of a SLD Filter Expression (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldFilterFromFilter = function (filter) {
        var _a;
        var _this = this;
        var sldFilter = [];
        if ((0, geostyler_style_1.isComparisonFilter)(filter)) {
            sldFilter = this.getSldComparisonFilterFromComparisonFilter(filter);
        }
        else if ((0, geostyler_style_1.isNegationFilter)(filter)) {
            sldFilter.push({
                Not: this.getSldFilterFromFilter(filter[1])
            });
        }
        else if ((0, geostyler_style_1.isCombinationFilter)(filter)) {
            var operator = filter[0], args = filter.slice(1);
            var sldOperators = (0, SldUtil_1.keysByValue)(SldStyleParser.combinationMap, operator);
            var combinator = sldOperators[0];
            var sldSubFilters = args.map(function (subFilter) { return _this.getSldFilterFromFilter(subFilter)[0]; });
            sldFilter.push((_a = {},
                _a[combinator] = sldSubFilters,
                _a));
        }
        return sldFilter;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from geostyler-style Symbolizers.
     *
     * @param symbolizers A geostyler-style Symbolizer array.
     * @return The object representation of a SLD Symbolizer (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldSymbolizersFromSymbolizers = function (symbolizers) {
        var _this = this;
        var sldSymbolizers = [];
        var PointSymbolizer = this.getTagName('PointSymbolizer');
        var TextSymbolizer = this.getTagName('TextSymbolizer');
        var LineSymbolizer = this.getTagName('LineSymbolizer');
        var PolygonSymbolizer = this.getTagName('PolygonSymbolizer');
        var RasterSymbolizer = this.getTagName('RasterSymbolizer');
        symbolizers.forEach(function (symb) {
            var sldSymbolizer = {};
            var sldSymb;
            switch (symb.kind) {
                case 'Mark':
                    sldSymb = _this.getSldPointSymbolizerFromMarkSymbolizer(symb);
                    sldSymbolizer[PointSymbolizer] = sldSymb;
                    break;
                case 'Icon':
                    sldSymb = _this.getSldPointSymbolizerFromIconSymbolizer(symb);
                    sldSymbolizer[PointSymbolizer] = sldSymb;
                    break;
                case 'Text':
                    sldSymb = _this.getSldTextSymbolizerFromTextSymbolizer(symb);
                    sldSymbolizer[TextSymbolizer] = sldSymb;
                    break;
                case 'Line':
                    sldSymb = _this.getSldLineSymbolizerFromLineSymbolizer(symb);
                    sldSymbolizer[LineSymbolizer] = sldSymb;
                    break;
                case 'Fill':
                    sldSymb = _this.getSldPolygonSymbolizerFromFillSymbolizer(symb);
                    sldSymbolizer[PolygonSymbolizer] = sldSymb;
                    break;
                case 'Raster':
                    sldSymb = _this.getSldRasterSymbolizerFromRasterSymbolizer(symb);
                    sldSymbolizer[RasterSymbolizer] = sldSymb;
                    break;
                default:
                    break;
            }
            sldSymbolizers.push(sldSymbolizer);
        });
        return sldSymbolizers;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style MarkSymbolizer.
     *
     * @param markSymbolizer A geostyler-style MarkSymbolizer.
     * @return The object representation of a SLD PointSymbolizer with a Mark
     */
    SldStyleParser.prototype.getSldPointSymbolizerFromMarkSymbolizer = function (markSymbolizer) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        var WellKnownName = this.getTagName('WellKnownName');
        var CssParameter = this.getTagName('CssParameter');
        var Fill = this.getTagName('Fill');
        var Mark = this.getTagName('Mark');
        var Stroke = this.getTagName('Stroke');
        var Opacity = this.getTagName('Opacity');
        var Rotation = this.getTagName('Rotation');
        var Size = this.getTagName('Size');
        var Graphic = this.getTagName('Graphic');
        var isFontSymbol = WELLKNOWNNAME_TTF_REGEXP.test(markSymbolizer.wellKnownName);
        var mark = [(_a = {},
                _a[WellKnownName] = [{
                        '#text': isFontSymbol ? markSymbolizer.wellKnownName : markSymbolizer.wellKnownName.toLowerCase()
                    }],
                _a)];
        if (markSymbolizer.color || markSymbolizer.fillOpacity) {
            var fillCssParamaters = [];
            if (markSymbolizer.color) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.color)) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.color);
                    fillCssParamaters.push((_b = {},
                        _b[CssParameter] = children,
                        _b[':@'] = {
                            '@_name': 'fill'
                        },
                        _b));
                }
                else {
                    fillCssParamaters.push((_c = {},
                        _c[CssParameter] = [{
                                '#text': markSymbolizer.color,
                            }],
                        _c[':@'] = {
                            '@_name': 'fill'
                        },
                        _c));
                }
            }
            if (markSymbolizer.fillOpacity) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.fillOpacity)) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.fillOpacity);
                    fillCssParamaters.push((_d = {},
                        _d[CssParameter] = children,
                        _d[':@'] = {
                            '@_name': 'fill-opacity'
                        },
                        _d));
                }
                else {
                    fillCssParamaters.push((_e = {},
                        _e[CssParameter] = [{
                                '#text': markSymbolizer.fillOpacity,
                            }],
                        _e[':@'] = {
                            '@_name': 'fill-opacity'
                        },
                        _e));
                }
            }
            mark.push((_f = {},
                _f[Fill] = fillCssParamaters,
                _f));
        }
        if (markSymbolizer.strokeColor || markSymbolizer.strokeWidth || markSymbolizer.strokeOpacity) {
            var strokeCssParameters = [];
            if (markSymbolizer.strokeColor) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.strokeColor)) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.strokeColor);
                    strokeCssParameters.push((_g = {},
                        _g[CssParameter] = children,
                        _g[':@'] = {
                            '@_name': 'stroke'
                        },
                        _g));
                }
                else {
                    strokeCssParameters.push((_h = {},
                        _h[CssParameter] = [{
                                '#text': markSymbolizer.strokeColor,
                            }],
                        _h[':@'] = {
                            '@_name': 'stroke'
                        },
                        _h));
                }
            }
            if (markSymbolizer.strokeWidth) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.strokeWidth)) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.strokeWidth);
                    strokeCssParameters.push((_j = {},
                        _j[CssParameter] = children,
                        _j[':@'] = {
                            '@_name': 'stroke-width'
                        },
                        _j));
                }
                else {
                    strokeCssParameters.push((_k = {},
                        _k[CssParameter] = [{
                                '#text': markSymbolizer.strokeWidth,
                            }],
                        _k[':@'] = {
                            '@_name': 'stroke-width'
                        },
                        _k));
                }
            }
            if (markSymbolizer.strokeOpacity) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.strokeOpacity)) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.strokeOpacity);
                    strokeCssParameters.push((_l = {},
                        _l[CssParameter] = children,
                        _l[':@'] = {
                            '@_name': 'stroke-opacity'
                        },
                        _l));
                }
                else {
                    strokeCssParameters.push((_m = {},
                        _m[CssParameter] = [{
                                '#text': markSymbolizer.strokeOpacity,
                            }],
                        _m[':@'] = {
                            '@_name': 'stroke-opacity'
                        },
                        _m));
                }
            }
            mark.push((_o = {},
                _o[Stroke] = strokeCssParameters,
                _o));
        }
        var graphic = [(_p = {},
                _p[Mark] = mark,
                _p)];
        if (markSymbolizer.opacity) {
            graphic.push((_q = {},
                _q[Opacity] = [{
                        '#text': markSymbolizer.opacity.toString()
                    }],
                _q));
        }
        if (markSymbolizer.radius !== undefined) {
            if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer.radius)) {
                graphic.push((_r = {},
                    // TODO: Double check if we have to multiply this by 2
                    _r[Size] = (0, SldUtil_1.geoStylerFunctionToSldFunction)(markSymbolizer.radius),
                    _r));
            }
            else {
                graphic.push((_s = {},
                    _s[Size] = [{
                            '#text': (markSymbolizer.radius * 2).toString()
                        }],
                    _s));
            }
        }
        if (markSymbolizer.rotate) {
            graphic.push((_t = {},
                _t[Rotation] = [{
                        '#text': markSymbolizer.rotate.toString()
                    }],
                _t));
        }
        return [(_u = {},
                _u[Graphic] = graphic,
                _u)];
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style IconSymbolizer.
     *
     * @param iconSymbolizer A geostyler-style IconSymbolizer.
     * @return The object representation of a SLD PointSymbolizer with
     * an "ExternalGraphic" (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldPointSymbolizerFromIconSymbolizer = function (iconSymbolizer) {
        var _a, _b, _c, _d, _e, _f;
        var ExternalGraphic = this.getTagName('ExternalGraphic');
        var Format = this.getTagName('Format');
        var OnlineResource = this.getTagName('OnlineResource');
        var Opacity = this.getTagName('Opacity');
        var Rotation = this.getTagName('Rotation');
        var Size = this.getTagName('Size');
        var Graphic = this.getTagName('Graphic');
        var graphic = [(_a = {},
                _a[ExternalGraphic] = [(_b = {},
                        _b[OnlineResource] = [],
                        _b[':@'] = {
                            '@_xlink:type': 'simple',
                            '@_xmlns:xlink': 'http://www.w3.org/1999/xlink',
                            '@_xlink:href': iconSymbolizer.image
                        },
                        _b)],
                _a)];
        if (typeof iconSymbolizer.image === 'string' || iconSymbolizer.image instanceof String) {
            var iconExt = iconSymbolizer.image.split('.').pop();
            switch (iconExt) {
                case 'png':
                case 'jpeg':
                case 'gif':
                    graphic[0][ExternalGraphic][0][Format] = ["image/".concat(iconExt)];
                    break;
                case 'jpg':
                    graphic[0][ExternalGraphic][0][Format] = ['image/jpeg'];
                    break;
                case 'svg':
                    graphic[0][ExternalGraphic][0][Format] = ['image/svg+xml'];
                    break;
                default:
                    break;
            }
        }
        if (iconSymbolizer.opacity) {
            graphic.push((_c = {},
                _c[Opacity] = [{
                        '#text': iconSymbolizer.opacity
                    }],
                _c));
        }
        if (iconSymbolizer.size) {
            graphic.push((_d = {},
                _d[Size] = [{
                        '#text': iconSymbolizer.size
                    }],
                _d));
        }
        if (iconSymbolizer.rotate) {
            graphic.push((_e = {},
                _e[Rotation] = [{
                        '#text': iconSymbolizer.rotate
                    }],
                _e));
        }
        return [(_f = {},
                _f[Graphic] = graphic,
                _f)];
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style TextSymbolizer.
     *
     * @param textSymbolizer A geostyler-style TextSymbolizer.
     * @return The object representation of a SLD TextSymbolizer (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldTextSymbolizerFromTextSymbolizer = function (textSymbolizer) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        var CssParameter = this.getTagName('CssParameter');
        var Fill = this.getTagName('Fill');
        var Halo = this.getTagName('Halo');
        var Font = this.getTagName('Font');
        var Displacement = this.getTagName('Displacement');
        var DisplacementX = this.getTagName('DisplacementX');
        var DisplacementY = this.getTagName('DisplacementY');
        var LabelPlacement = this.getTagName('LabelPlacement');
        var PointPlacement = this.getTagName('PointPlacement');
        var Rotation = this.getTagName('Rotation');
        var Radius = this.getTagName('Radius');
        var Label = this.getTagName('Label');
        var sldTextSymbolizer = [(_a = {},
                _a[Label] = textSymbolizer.label ? this.getSldLabelFromTextSymbolizer(textSymbolizer.label) : undefined,
                _a)];
        var fontPropertyMap = {
            font: 'font-family',
            size: 'font-size',
            fontStyle: 'font-style',
            fontWeight: 'font-weight'
        };
        var fontCssParameters = Object.keys(textSymbolizer)
            .filter(function (property) { return property !== 'kind' && fontPropertyMap[property]; })
            .map(function (property) {
            var _a, _b;
            if ((0, geostyler_style_1.isGeoStylerFunction)(textSymbolizer[property])) {
                var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(textSymbolizer[property]);
                return _a = {},
                    _a[CssParameter] = children,
                    _a[':@'] = {
                        '@_name': fontPropertyMap[property]
                    },
                    _a;
            }
            else {
                return _b = {},
                    _b[CssParameter] = [{
                            '#text': property === 'font'
                                ? textSymbolizer[property][0]
                                : textSymbolizer[property],
                        }],
                    _b[':@'] = {
                        '@_name': fontPropertyMap[property]
                    },
                    _b;
            }
        });
        if (fontCssParameters.length > 0) {
            sldTextSymbolizer.push((_b = {},
                _b[Font] = fontCssParameters,
                _b));
        }
        if (textSymbolizer.offset || textSymbolizer.rotate !== undefined) {
            var pointPlacement = [];
            if (textSymbolizer.offset) {
                pointPlacement.push((_c = {},
                    _c[Displacement] = [(_d = {},
                            _d[DisplacementX] = [{
                                    '#text': textSymbolizer.offset[0].toString()
                                }],
                            _d), (_e = {},
                            _e[DisplacementY] = [{
                                    '#text': textSymbolizer.offset[1].toString()
                                }],
                            _e)],
                    _c));
            }
            if (textSymbolizer.rotate !== undefined) {
                pointPlacement.push((_f = {},
                    _f[Rotation] = [{
                            '#text': textSymbolizer.rotate.toString()
                        }],
                    _f));
            }
            sldTextSymbolizer.push((_g = {},
                _g[LabelPlacement] = [(_h = {},
                        _h[PointPlacement] = pointPlacement,
                        _h)],
                _g));
        }
        if (textSymbolizer.haloWidth || textSymbolizer.haloColor) {
            var halo = [];
            var haloFillCssParameter = [];
            if (textSymbolizer.haloWidth) {
                halo.push((_j = {},
                    _j[Radius] = [{
                            '#text': textSymbolizer.haloWidth.toString()
                        }],
                    _j));
            }
            if (textSymbolizer.haloColor) {
                haloFillCssParameter.push((_k = {},
                    _k[CssParameter] = [{
                            '#text': textSymbolizer.haloColor,
                        }],
                    _k[':@'] = {
                        '@_name': 'fill'
                    },
                    _k));
            }
            if (textSymbolizer.haloOpacity) {
                haloFillCssParameter.push((_l = {},
                    _l[CssParameter] = [{
                            '#text': textSymbolizer.haloOpacity,
                        }],
                    _l[':@'] = {
                        '@_name': 'fill-opacity'
                    },
                    _l));
            }
            if (haloFillCssParameter.length > 0) {
                halo.push((_m = {},
                    _m[Fill] = haloFillCssParameter,
                    _m));
            }
            sldTextSymbolizer.push((_o = {},
                _o[Halo] = halo,
                _o));
        }
        if (textSymbolizer.color || textSymbolizer.opacity) {
            var fill = [(_p = {},
                    _p[CssParameter] = [{
                            '#text': textSymbolizer.color || '#000000',
                        }],
                    _p[':@'] = {
                        '@_name': 'fill'
                    },
                    _p), (_q = {},
                    _q[CssParameter] = [{
                            '#text': textSymbolizer.opacity || '1',
                        }],
                    _q[':@'] = {
                        '@_name': 'fill-opacity'
                    },
                    _q)];
            sldTextSymbolizer.push((_r = {},
                _r[Fill] = fill,
                _r));
        }
        return sldTextSymbolizer;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style LineSymbolizer.
     *
     * @param lineSymbolizer A geostyler-style LineSymbolizer.
     * @return The object representation of a SLD LineSymbolizer (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldLineSymbolizerFromLineSymbolizer = function (lineSymbolizer) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m, _o, _p, _q, _r, _s;
        var CssParameter = this.getTagName('CssParameter');
        var Stroke = this.getTagName('Stroke');
        var GraphicStroke = this.getTagName('GraphicStroke');
        var GraphicFill = this.getTagName('GraphicFill');
        var PerpendicularOffset = this.getTagName('PerpendicularOffset');
        var propertyMap = {
            color: 'stroke',
            width: 'stroke-width',
            opacity: 'stroke-opacity',
            join: 'stroke-linejoin',
            cap: 'stroke-linecap',
            dasharray: 'stroke-dasharray',
            dashOffset: 'stroke-dashoffset'
        };
        var sldLineSymbolizer = [];
        var cssParameters = Object.keys(lineSymbolizer)
            .filter(function (property) { return property !== 'kind' && propertyMap[property] &&
            lineSymbolizer[property] !== undefined && lineSymbolizer[property] !== null; })
            .map(function (property) {
            var _a, _b, _c;
            var value = lineSymbolizer[property];
            if (property === 'dasharray') {
                value = lineSymbolizer.dasharray ? lineSymbolizer.dasharray.join(' ') : undefined;
                return _a = {},
                    _a[CssParameter] = [{
                            '#text': value,
                        }],
                    _a[':@'] = {
                        '@_name': propertyMap[property]
                    },
                    _a;
            }
            // simple transformation since geostyler-style uses prop 'miter' whereas sld uses 'mitre'
            if (property === 'join' && value === 'miter') {
                value = 'mitre';
            }
            if ((0, geostyler_style_1.isGeoStylerFunction)(lineSymbolizer[property])) {
                var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(lineSymbolizer[property]);
                return _b = {},
                    _b[CssParameter] = children,
                    _b[':@'] = {
                        '@_name': propertyMap[property]
                    },
                    _b;
            }
            else {
                return _c = {},
                    _c[CssParameter] = [{
                            '#text': lineSymbolizer[property],
                        }],
                    _c[':@'] = {
                        '@_name': propertyMap[property]
                    },
                    _c;
            }
        });
        if (lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicStroke) {
            if (!Array.isArray((_l = sldLineSymbolizer === null || sldLineSymbolizer === void 0 ? void 0 : sldLineSymbolizer[0]) === null || _l === void 0 ? void 0 : _l[Stroke])) {
                sldLineSymbolizer[0] = (_a = {}, _a[Stroke] = [], _a);
            }
            if (((_m = lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicStroke) === null || _m === void 0 ? void 0 : _m.kind) === 'Mark') {
                var graphicStroke = this.getSldPointSymbolizerFromMarkSymbolizer(lineSymbolizer.graphicStroke);
                sldLineSymbolizer[0][Stroke].push((_b = {},
                    _b[GraphicStroke] = graphicStroke,
                    _b));
            }
            else if (((_o = lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicStroke) === null || _o === void 0 ? void 0 : _o.kind) === 'Icon') {
                var graphicStroke = this.getSldPointSymbolizerFromIconSymbolizer(lineSymbolizer.graphicStroke);
                sldLineSymbolizer[0][Stroke].push((_c = {},
                    _c[GraphicStroke] = graphicStroke,
                    _c));
            }
        }
        if (lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicFill) {
            if (!Array.isArray((_p = sldLineSymbolizer === null || sldLineSymbolizer === void 0 ? void 0 : sldLineSymbolizer[0]) === null || _p === void 0 ? void 0 : _p[Stroke])) {
                sldLineSymbolizer[0] = (_d = {}, _d[Stroke] = [], _d);
            }
            if (((_q = lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicFill) === null || _q === void 0 ? void 0 : _q.kind) === 'Mark') {
                var graphicFill = this.getSldPointSymbolizerFromMarkSymbolizer(lineSymbolizer.graphicFill);
                sldLineSymbolizer[0][Stroke].push((_e = {},
                    _e[GraphicFill] = graphicFill,
                    _e));
            }
            else if (((_r = lineSymbolizer === null || lineSymbolizer === void 0 ? void 0 : lineSymbolizer.graphicFill) === null || _r === void 0 ? void 0 : _r.kind) === 'Icon') {
                var graphicFill = this.getSldPointSymbolizerFromIconSymbolizer(lineSymbolizer.graphicFill);
                sldLineSymbolizer[0][Stroke].push((_f = {},
                    _f[GraphicFill] = graphicFill,
                    _f));
            }
        }
        if (cssParameters.length !== 0) {
            if (!Array.isArray((_s = sldLineSymbolizer === null || sldLineSymbolizer === void 0 ? void 0 : sldLineSymbolizer[0]) === null || _s === void 0 ? void 0 : _s[Stroke])) {
                sldLineSymbolizer[0] = (_g = {}, _g[Stroke] = [], _g);
            }
            (_h = sldLineSymbolizer[0][Stroke]).push.apply(_h, cssParameters);
        }
        if (lineSymbolizer.perpendicularOffset) {
            sldLineSymbolizer.push((_j = {},
                _j[PerpendicularOffset] = [
                    {
                        '#text': lineSymbolizer.perpendicularOffset
                    }
                ],
                _j));
        }
        if (sldLineSymbolizer.length === 0) {
            sldLineSymbolizer.push((_k = {},
                _k[Stroke] = {},
                _k));
        }
        return sldLineSymbolizer;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style FillSymbolizer.
     *
     * @param fillSymbolizer A geostyler-style FillSymbolizer.
     * @return The object representation of a SLD PolygonSymbolizer (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldPolygonSymbolizerFromFillSymbolizer = function (fillSymbolizer) {
        var _a, _b, _c;
        var _d;
        var CssParameter = this.getTagName('CssParameter');
        var Stroke = this.getTagName('Stroke');
        var Fill = this.getTagName('Fill');
        var strokePropertyMap = {
            outlineColor: 'stroke',
            outlineWidth: 'stroke-width',
            outlineOpacity: 'stroke-opacity',
            outlineDasharray: 'stroke-dasharray',
            outlineCap: 'stroke-linecap',
            outlineJoin: 'stroke-linejoin'
        };
        var fillPropertyMap = {
            color: 'fill',
            fillOpacity: 'fill-opacity'
        };
        var strokeCssParameters = [];
        var fillCssParameters = [];
        var graphicFill;
        if (fillSymbolizer === null || fillSymbolizer === void 0 ? void 0 : fillSymbolizer.graphicFill) {
            if ((fillSymbolizer === null || fillSymbolizer === void 0 ? void 0 : fillSymbolizer.graphicFill.kind) === 'Mark') {
                graphicFill = this.getSldPointSymbolizerFromMarkSymbolizer(fillSymbolizer.graphicFill);
            }
            else if ((fillSymbolizer === null || fillSymbolizer === void 0 ? void 0 : fillSymbolizer.graphicFill.kind) === 'Icon') {
                graphicFill = this.getSldPointSymbolizerFromIconSymbolizer(fillSymbolizer.graphicFill);
            }
        }
        Object.keys(fillSymbolizer)
            .filter(function (property) { return property !== 'kind'; })
            .filter(function (property) { return fillSymbolizer[property] !== undefined && fillSymbolizer[property] !== null; })
            .forEach(function (property) {
            var _a, _b, _c, _d;
            if (Object.keys(fillPropertyMap).includes(property)) {
                if ((0, geostyler_style_1.isGeoStylerFunction)(fillSymbolizer[property])) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(fillSymbolizer[property]);
                    fillCssParameters.push((_a = {},
                        _a[CssParameter] = children,
                        _a[':@'] = {
                            '@_name': fillPropertyMap[property]
                        },
                        _a));
                }
                else {
                    fillCssParameters.push((_b = {},
                        _b[CssParameter] = [{
                                '#text': fillSymbolizer[property],
                            }],
                        _b[':@'] = {
                            '@_name': fillPropertyMap[property]
                        },
                        _b));
                }
            }
            else if (Object.keys(strokePropertyMap).includes(property)) {
                var transformedValue_1 = '';
                if (property === 'outlineDasharray') {
                    var paramValue_1 = fillSymbolizer[property];
                    transformedValue_1 = '';
                    paramValue_1.forEach(function (dash, idx) {
                        transformedValue_1 += dash;
                        if (idx < paramValue_1.length - 1) {
                            transformedValue_1 += ' ';
                        }
                    });
                }
                else if (property === 'outlineWidth') {
                    transformedValue_1 = fillSymbolizer[property] + '';
                }
                else if (property === 'outlineOpacity') {
                    transformedValue_1 = fillSymbolizer[property] + '';
                }
                else {
                    transformedValue_1 = fillSymbolizer[property];
                }
                if ((0, geostyler_style_1.isGeoStylerFunction)(fillSymbolizer[property])) {
                    var children = (0, SldUtil_1.geoStylerFunctionToSldFunction)(fillSymbolizer[property]);
                    strokeCssParameters.push((_c = {},
                        _c[CssParameter] = children,
                        _c[':@'] = {
                            '@_name': strokePropertyMap[property]
                        },
                        _c));
                }
                else {
                    strokeCssParameters.push((_d = {},
                        _d[CssParameter] = [{
                                '#text': transformedValue_1,
                            }],
                        _d[':@'] = {
                            '@_name': strokePropertyMap[property]
                        },
                        _d));
                }
            }
        });
        var polygonSymbolizer = [];
        if (fillCssParameters.length > 0 || graphicFill) {
            if (!Array.isArray((_d = polygonSymbolizer === null || polygonSymbolizer === void 0 ? void 0 : polygonSymbolizer[0]) === null || _d === void 0 ? void 0 : _d[Fill])) {
                polygonSymbolizer[0] = (_a = {}, _a[Fill] = [], _a);
            }
            if (fillCssParameters.length > 0) {
                (_b = polygonSymbolizer[0][Fill]).push.apply(_b, fillCssParameters);
            }
            if (graphicFill) {
                polygonSymbolizer[0][Fill].push({
                    GraphicFill: graphicFill
                });
            }
        }
        if (strokeCssParameters.length > 0) {
            polygonSymbolizer.push((_c = {},
                _c[Stroke] = strokeCssParameters,
                _c));
        }
        return polygonSymbolizer;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style RasterSymbolizer.
     *
     * @param rasterSymbolizer A geostyler-style RasterSymbolizer.
     * @return The object representation of a SLD RasterSymbolizer (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldRasterSymbolizerFromRasterSymbolizer = function (rasterSymbolizer) {
        var sldRasterSymbolizer = [{}];
        if (rasterSymbolizer.opacity !== undefined) {
            sldRasterSymbolizer[0].Opacity = [{
                    '#text': rasterSymbolizer.opacity
                }];
        }
        var colorMap;
        if (rasterSymbolizer.colorMap) {
            colorMap = this.getSldColorMapFromColorMap(rasterSymbolizer.colorMap);
            if (colorMap === null || colorMap === void 0 ? void 0 : colorMap[0]) {
                sldRasterSymbolizer.push({
                    ColorMap: colorMap
                });
            }
        }
        var channelSelection;
        if (rasterSymbolizer.channelSelection) {
            channelSelection = this.getSldChannelSelectionFromChannelSelection(rasterSymbolizer.channelSelection);
            if (channelSelection === null || channelSelection === void 0 ? void 0 : channelSelection[0]) {
                sldRasterSymbolizer.push({
                    ChannelSelection: channelSelection
                });
            }
        }
        var contrastEnhancement;
        if (rasterSymbolizer.contrastEnhancement) {
            contrastEnhancement = this.getSldContrastEnhancementFromContrastEnhancement(rasterSymbolizer.contrastEnhancement);
            if (contrastEnhancement === null || contrastEnhancement === void 0 ? void 0 : contrastEnhancement[0]) {
                sldRasterSymbolizer.push({
                    ContrastEnhancement: contrastEnhancement
                });
            }
        }
        return sldRasterSymbolizer;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style ColorMap.
     *
     * @param colorMap A geostyler-style ColorMap.
     * @return The object representation of a SLD ColorMap (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldColorMapFromColorMap = function (colorMap) {
        var sldColorMap = [];
        // parse colorMap.type
        if (colorMap.type) {
            var type = colorMap.type;
            sldColorMap[':@'] = {
                '@_type': type
            };
        }
        // parse colorMap.extended
        if (colorMap.extended !== undefined) {
            var extended = colorMap.extended.toString();
            if (!sldColorMap[':@']) {
                sldColorMap[':@'] = {};
            }
            sldColorMap[':@']['@_extended'] = extended;
        }
        // parse colorMap.colorMapEntries
        if (colorMap.colorMapEntries && colorMap.colorMapEntries.length > 0) {
            var colorMapEntries = colorMap.colorMapEntries.map(function (entry) {
                var result = {
                    ColorMapEntry: [],
                    ':@': {}
                };
                if (entry.color) {
                    result[':@']['@_color'] = entry.color;
                }
                if (typeof entry.quantity !== 'undefined') {
                    result[':@']['@_quantity'] = entry.quantity.toString();
                }
                if (entry.label) {
                    result[':@']['@_label'] = entry.label;
                }
                if (typeof entry.opacity !== 'undefined') {
                    result[':@']['@_opacity'] = entry.opacity.toString();
                }
                return result;
                // remove empty colorMapEntries
            }).filter(function (entry) { return Object.keys(entry).length > 0; });
            sldColorMap.push.apply(sldColorMap, colorMapEntries);
        }
        return sldColorMap;
    };
    /**
     * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style ChannelSelection.
     *
     * @param channelSelection A geostyler-style ChannelSelection.
     * @return The object representation of a SLD ChannelSelection (readable with fast-xml-parser)
     */
    SldStyleParser.prototype.getSldChannelSelectionFromChannelSelection = function (channelSelection) {
        var _this = this;
        var propertyMap = {
            redChannel: 'RedChannel',
            blueChannel: 'BlueChannel',
            greenChannel: 'GreenChannel',
            grayChannel: 'GrayChannel'
        };
        var keys = Object.keys(channelSelection);
        var sldChannelSelection = [];
        keys.forEach(function (key) {
            var _a;
            var _b, _c;
            var channel = [];
            // parse sourceChannelName
            var sourceChannelName = (_b = channelSelection === null || channelSelection === void 0 ? void 0 : channelSelection[key]) === null || _b === void 0 ? void 0 : _b.sourceChannelName;
            var channelName = propertyMap[key];
            // parse contrastEnhancement
            var contrastEnhancement = (_c = channelSelection === null || channelSelection === void 0 ? void 0 : channelSelection[key]) === null || _c === void 0 ? void 0 : _c.contrastEnhancement;
            if (sourceChannelName || contrastEnhancement) {
                if (sourceChannelName) {
                    channel.push({
                        SourceChannelName: [{
                                '#text': sourceChannelName
                            }]
                    });
                }
                if (contrastEnhancement) {
                    channel.push({
                        ContrastEnhancement: _this.getSldContrastEnhancementFromContrastEnhancement(contrastEnhancement)
                    });
                }
                sldChannelSelection.push((_a = {},
                    _a[channelName] = channel,
                    _a));
            }
        });
        return sldChannelSelection;
    };
    /**
       * Get the SLD Object (readable with fast-xml-parser) from a geostyler-style ContrastEnhancement.
       *
       * @param contrastEnhancement A geostyler-style ContrastEnhancement.
       * @return The object representation of a SLD ContrastEnhancement (readable with fast-xml-parser)
       */
    SldStyleParser.prototype.getSldContrastEnhancementFromContrastEnhancement = function (contrastEnhancement) {
        var sldContrastEnhancement = [];
        var enhancementType = contrastEnhancement === null || contrastEnhancement === void 0 ? void 0 : contrastEnhancement.enhancementType;
        if (enhancementType === 'normalize') {
            // parse normalize
            sldContrastEnhancement.push({
                Normalize: []
            });
        }
        else if (enhancementType === 'histogram') {
            // parse histogram
            sldContrastEnhancement.push({
                Histogram: []
            });
        }
        // parse gammaValue
        if (contrastEnhancement.gammaValue !== undefined) {
            sldContrastEnhancement.push({
                GammaValue: [{
                        '#text': contrastEnhancement.gammaValue
                    }]
            });
        }
        return sldContrastEnhancement;
    };
    SldStyleParser.prototype.checkForUnsupportedProperites = function (geoStylerStyle) {
        var _this = this;
        var capitalizeFirstLetter = function (a) { return a[0].toUpperCase() + a.slice(1); };
        var unsupportedProperties = {};
        geoStylerStyle.rules.forEach(function (rule) {
            // ScaleDenominator and Filters are completely supported so we just check for symbolizers
            rule.symbolizers.forEach(function (symbolizer) {
                var _a, _b;
                var key = capitalizeFirstLetter("".concat(symbolizer.kind, "Symbolizer"));
                var value = (_b = (_a = _this.unsupportedProperties) === null || _a === void 0 ? void 0 : _a.Symbolizer) === null || _b === void 0 ? void 0 : _b[key];
                if (value) {
                    if (typeof value === 'string' || value instanceof String) {
                        if (!unsupportedProperties.Symbolizer) {
                            unsupportedProperties.Symbolizer = {};
                        }
                        unsupportedProperties.Symbolizer[key] = value;
                    }
                    else {
                        Object.keys(symbolizer).forEach(function (property) {
                            if (value[property]) {
                                if (!unsupportedProperties.Symbolizer) {
                                    unsupportedProperties.Symbolizer = {};
                                }
                                if (!unsupportedProperties.Symbolizer[key]) {
                                    unsupportedProperties.Symbolizer[key] = {};
                                }
                                unsupportedProperties.Symbolizer[key][property] = value[property];
                            }
                        });
                    }
                }
            });
        });
        if (Object.keys(unsupportedProperties).length > 0) {
            return unsupportedProperties;
        }
        return undefined;
    };
    /**
     * The name of the SLD Style Parser.
     */
    SldStyleParser.title = 'SLD Style Parser';
    SldStyleParser.negationOperatorMap = {
        Not: '!'
    };
    SldStyleParser.combinationMap = {
        And: '&&',
        Or: '||',
        PropertyIsBetween: '&&'
    };
    SldStyleParser.comparisonMap = {
        PropertyIsEqualTo: '==',
        PropertyIsNotEqualTo: '!=',
        PropertyIsLike: '*=',
        PropertyIsLessThan: '<',
        PropertyIsLessThanOrEqualTo: '<=',
        PropertyIsGreaterThan: '>',
        PropertyIsGreaterThanOrEqualTo: '>=',
        PropertyIsNull: '==',
        PropertyIsBetween: '<=x<='
    };
    return SldStyleParser;
}());
exports.SldStyleParser = SldStyleParser;
exports.default = SldStyleParser;
//# sourceMappingURL=SldStyleParser.js.map