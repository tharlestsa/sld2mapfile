"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapfileStyleParser = void 0;
var parseMapfile_1 = require("./mapfile2js/parseMapfile");
var Useful_1 = require("./Useful");
var Logger_1 = __importDefault(require("@terrestris/base-util/dist/Logger"));
/**
 * This parser can be used with the GeoStyler.
 * It implements the GeoStyler-Style StyleParser interface.
 *
 * @class MapfileStyleParser
 * @implements StyleParser
 */
var MapfileStyleParser = /** @class */ (function () {
    function MapfileStyleParser(opts) {
        this.title = 'Mapfile Style Parser';
        this.symbolsPath = process.cwd() + "/symbols.sym";
        Object.assign(this, opts);
    }
    /**
     * Get the name for the Style from the Mapfile LAYER. Returns the GROUP value of the LAYER
     * if defined or the NAME value of the LAYER if defined or an empty string.
     *
     * @param {MapfileLayer} mapfileLayer The Mapfile Layer object representation (created with mapfile2js)
     * @return {string} The name to be used for the GeoStyler Style Style
     */
    MapfileStyleParser.prototype.getStyleNameFromMapfileLayer = function (mapfileLayer) {
        var layerName = mapfileLayer.name;
        return layerName ? layerName : '';
    };
    /**
     * Get the GeoStyler-Style Filter from an Mapfile EXPRESSION and CLASSITEM.
     *
     * @param {MapfileClass} mapfileClass The Mapfile Class
     * @param {string} mapfileClassItem The Mapfile Class
     * @return {Filter} The GeoStyler-Style Filter
     */
    MapfileStyleParser.prototype.getFilterFromClassItem = function (mapfileClass, mapfileClassItem) {
        if (!mapfileClassItem) {
            Logger_1.default.error(mapfileClassItem, 'Mapfile CLASSITEM undefined!');
        }
        var expression = mapfileClass.expression;
        switch (expression.charAt(0)) {
            case '"':
                return ['==', mapfileClassItem, expression.substring(1, expression.length - 1)];
            case '/':
                return ['*=', ['FN_strMatches', mapfileClassItem, expression], true];
            case '{':
                return [
                    '*=',
                    [
                        'FN_strMatches',
                        mapfileClassItem,
                        "/(" + expression.substring(1, expression.length - 1).replace(/,/g, '|') + ")/"
                    ],
                    true,
                ];
            default:
                Logger_1.default.error("Unable to get Filter from CLASSITEM: " + mapfileClass);
        }
        return null;
    };
    /**
     * Get the GeoStyler-Style Filter from an Mapfile EXPRESSION.
     *
     * @param {string} attribute The Mapfile Expression Attribute
     * @param {string} operator The Mapfile Expression Operator
     * @param {string} value The Mapfile Expression Value
     * @return {Filter} The GeoStyler-Style Filter
     */
    MapfileStyleParser.prototype.getFilterFromAttributeValueComparison = function (attribute, operator, value) {
        // substitude operator variations (may be rewritten using a map)
        operator = operator
            .replace(/^=$/, '==')
            .replace('eq', '==')
            .replace('ne', '!=')
            .replace('lt', '<')
            .replace('gt', '>')
            .replace('le', '<=')
            .replace('ge', '>=');
        // TODO: assert there are no qotes in strings, either of!
        switch (operator) {
            case '~': {
                var valueOrNumber = /^[-\d]/.test(value) ? parseFloat(value) : value;
                return ['*=', ['FN_strMatches', attribute, valueOrNumber], true];
            }
            case '~*':
                return ['*=', ['FN_strMatches', attribute, value + "i"], true];
            case 'IN':
                return [
                    '*=',
                    [
                        'FN_strMatches',
                        attribute,
                        "/" + value
                            .substring(1, value.length - 1)
                            .replace(',', '|') + "/"
                    ],
                    true,
                ];
            case '==':
            case '!=':
            case '<':
            case '>':
            case '<=':
            case '>=': {
                var valueOrNumber = /^[-\d]/.test(value) ? parseFloat(value) : value;
                return [operator, attribute, valueOrNumber];
            }
            default:
                Logger_1.default.error("Unknow comparison operator: " + operator);
                return null;
        }
    };
    /**
     * Get the GeoStyler-Style Filter from an Mapfile EXPRESSION.
     *
     * @param {string} mapfileExpression The Mapfile Expression
     * @return {Filter} The GeoStyler-Style Filter
     */
    MapfileStyleParser.prototype.getFilterFromMapfileExpression = function (mapfileExpression) {
        var _this = this;
        // remove surrounding parantheses
        if (/^\(.+\)$/.test(mapfileExpression)) {
            mapfileExpression = mapfileExpression.replace(/(^\(\s*|\s*\)$)/g, '');
        }
        // capture nested expressions
        if (/^\(/.test(mapfileExpression)) {
            // split up nested expression
            var nestedExpressions = this.splitNestedExpression(mapfileExpression);
            var operator = void 0;
            if (mapfileExpression.includes('AND')) {
                operator = '&&';
            }
            else if (mapfileExpression.includes('OR')) {
                operator = '||';
            }
            var filterExpressions_1 = [];
            nestedExpressions.forEach(function (nestedExpression) {
                filterExpressions_1.push(_this.getFilterFromMapfileExpression(nestedExpression));
            });
            return __spreadArray([
                operator
            ], filterExpressions_1, true);
        }
        // capture negation
        if (/^(!|NOT)/.test(mapfileExpression)) {
            mapfileExpression = mapfileExpression.replace(/^(!|NOT)\s*/, '');
            return [
                '!',
                this.getFilterFromMapfileExpression(mapfileExpression),
            ];
        }
        // get filter from common expression "[attribute] operator value"
        if (/^['"]?\[/.test(mapfileExpression)) {
            // get attribute
            var attributeMatch = mapfileExpression.match(/^['"]?\[([^\]]+)\]['"]?\s*/);
            mapfileExpression = mapfileExpression.replace(/^['"]?\[[^\]]+\]['"]?\s*/, '');
            // get operator
            var operator = mapfileExpression.split(/\s/)[0];
            mapfileExpression = mapfileExpression.replace(/^[^\s]+\s/, '');
            // get literal, number or regex
            var valueMatch = mapfileExpression.match(/^['"]?([^)'"]+)['"]?\s*/);
            mapfileExpression = mapfileExpression.replace(/^['"]?[^)'"]+['"]?\s*/, '');
            if (attributeMatch && operator && valueMatch) {
                return this.getFilterFromAttributeValueComparison(attributeMatch[1], operator, valueMatch[1]);
            }
            else {
                Logger_1.default.error("Unable to parse common expression: " + attributeMatch + ", " + operator + ", " + valueMatch);
            }
        }
        // TODO: implement logical combination expression relying on operator precedence
        if (mapfileExpression.length > 0) {
            Logger_1.default.warn("Mapfile expression leftovers: " + mapfileExpression);
        }
        return null;
    };
    /**
     * Get the GeoStyler-Style Filter from a Mapfile CLASS.
     *
     * @param {MapfileClass} mapfileClass The Mapfile Class
     * @return {Filter} The GeoStyler-Style Filter
     */
    MapfileStyleParser.prototype.getFilterFromMapfileClass = function (mapfileClass, mapfileLayerClassItem) {
        var expression = mapfileClass.expression;
        if (!expression) {
            return null;
        }
        // assert expression contains no string functions, arithmetic operations or spatial components
        if (/tostring \(|commify \(|upper \(|lower \(|initcap \(|firstcap \(|length \(/.test(expression)) {
            Logger_1.default.error("Not able to parse string function: " + expression);
        }
        else if (/round \(| \+ | - | \* | \/ | \^ | % /.test(expression)) {
            Logger_1.default.error("Not able to parse arithmetic operator or function: " + expression);
            return null;
        }
        else if ([
            'intersects (',
            'disjoint (',
            'touches (',
            'overlaps (',
            'crosses (',
            'within (',
            'contains (',
            'dwithin (',
            'beyond (',
            'area (',
            'fromtext (',
            'buffer (',
            'difference (',
        ].some(function (spatialComponent) { return expression.includes(spatialComponent); })) {
            Logger_1.default.error("Not able to parse spatial expression: " + expression);
            return null;
        }
        else if (expression.includes('Â´')) {
            Logger_1.default.error("Not able to parse temporal expression: " + expression);
            return null;
        }
        // assert expression does not contain escaped quotes
        if (/\\'|\\"/.test(expression)) {
            Logger_1.default.error("Mapfile expression may contain escaped quote: " + expression);
        }
        // get filter from expression value targeting CLASSITEM
        if (/^["/{]/.test(expression)) {
            return this.getFilterFromClassItem(mapfileClass, mapfileLayerClassItem);
        }
        // assert expression starts and ends with a bracket
        if (!/^\(.+\)$/.test(expression)) {
            Logger_1.default.error("Malformed expression! " + expression);
        }
        // get filter by expression parsing
        return this.getFilterFromMapfileExpression(expression);
    };
    /**
     * Get the GeoStyler-Style ScaleDenominator from an Mapfile element (layer, class or style).
     * Returns null if there is no defined ScaleDenominator in the element.
     * @param {MapfileLayer | MapfileClass | MapfileStyle} mapfileElement The Mapfile layer, class or style.
     * @return {ScaleDenominator} The GeoStyler-Style ScaleDenominator or null.
     */
    MapfileStyleParser.prototype.getScaleDenominator = function (mapfileElement) {
        var scaleDenominator = {};
        // TODO: fixme, should this fetch the layers layermaxscaledenom too?
        if ('maxscaledenom' in mapfileElement) {
            if (mapfileElement.maxscaledenom) {
                scaleDenominator.max = mapfileElement.maxscaledenom * 1;
            }
        }
        // TODO: fixme, should this fetch the layers layerminscaledenom too?
        if ('minscaledenom' in mapfileElement) {
            if (mapfileElement.minscaledenom) {
                scaleDenominator.min = mapfileElement.minscaledenom * 1;
            }
        }
        return scaleDenominator.max !== undefined || scaleDenominator.min !== undefined ? scaleDenominator : null;
    };
    /**
     * Update the given scaleDenominator with the scaleDenominator from the given mapfileElement;
     *
     * @param {MapfileLayer | MapfileClass | MapfileStyle} mapfileElement The Mapfile layer, class or style.
     * @param {ScaleDenominator} scaleDenominator The scaleDenominator to try to override.
     * @return {scaleDenominator} A ScaleDenominator value or null.
     */
    MapfileStyleParser.prototype.updateScaleDenominator = function (mapfileElement, scaleDenominator) {
        var elementScaleDenominator = this.getScaleDenominator(mapfileElement);
        // No child scale - can't update, return the base scaleDenominator.
        if (!elementScaleDenominator) {
            return scaleDenominator;
        }
        // No parent scale - return the child scaleDenominator.
        if (!scaleDenominator) {
            return elementScaleDenominator;
        }
        var mergedScale = {};
        // Take max scale only if it's defined and take children max scale if it's defined additionally (more specific)
        if (scaleDenominator.max === undefined && elementScaleDenominator.max !== undefined) {
            mergedScale.max = elementScaleDenominator.max;
        }
        else if (scaleDenominator.max !== undefined && elementScaleDenominator.max === undefined) {
            mergedScale.max = scaleDenominator.max;
        }
        else if (scaleDenominator.max !== undefined && elementScaleDenominator.max !== undefined) {
            mergedScale.max = elementScaleDenominator.max;
        }
        // Take min scale only if it's defined and take children min scale it's defined additionally (more specific)
        if (scaleDenominator.min === undefined && elementScaleDenominator.min !== undefined) {
            mergedScale.min = elementScaleDenominator.min;
        }
        else if (scaleDenominator.min !== undefined && elementScaleDenominator.min === undefined) {
            mergedScale.min = scaleDenominator.min;
        }
        else if (scaleDenominator.min !== undefined && elementScaleDenominator.min !== undefined) {
            mergedScale.min = elementScaleDenominator.min;
        }
        return mergedScale;
    };
    /**
     * Get the GeoStyler-Style MarkSymbolizer from an Mapfile STYLE
     *
     * @param {MapfileStyle} mapfileStyle The Mapfile Style Parameters
     * @return {MarkSymbolizer} The GeoStyler-Style MarkSymbolizer
     */
    MapfileStyleParser.prototype.getMarkSymbolizerFromMapfileStyle = function (mapfileStyle) {
        var markSymbolizer = { kind: 'Mark' };
        if (!mapfileStyle.color) {
            markSymbolizer.visibility = false;
        }
        if (mapfileStyle.symbol.filled) {
            markSymbolizer.fillOpacity = mapfileStyle.symbol.filled.toLowerCase() === 'true' ? 1 : 0;
        }
        else {
            markSymbolizer.fillOpacity = 0;
        }
        if (mapfileStyle.size) {
            markSymbolizer.radius = mapfileStyle.size / 2;
        }
        markSymbolizer.rotate = mapfileStyle.angle ? Number(mapfileStyle.angle) : 0;
        if (mapfileStyle.outlinecolor) {
            markSymbolizer.strokeColor = (0, Useful_1.isHex)(mapfileStyle.outlinecolor)
                ? mapfileStyle.outlinecolor
                : (0, Useful_1.rgbToHex)(mapfileStyle.outlinecolor);
            if (mapfileStyle.opacity) {
                markSymbolizer.strokeOpacity = mapfileStyle.opacity / 100;
            }
        }
        if (mapfileStyle.width) {
            markSymbolizer.strokeWidth = mapfileStyle.width * 1;
        }
        var symbolType = mapfileStyle.symbol.type.toLowerCase();
        if (mapfileStyle.symbol.points) {
            var points = mapfileStyle.symbol.points.split(' ').map(function (item) { return parseFloat(item); });
            if (symbolType === 'ellipse' && points[0] === points[1] && points.length === 2) {
                markSymbolizer.wellKnownName = 'circle';
            }
            else {
                if ((0, Useful_1.isSquare)(points)) {
                    markSymbolizer.wellKnownName = 'square';
                }
                if ((0, Useful_1.isTriangle)(points)) {
                    markSymbolizer.wellKnownName = 'triangle';
                }
                if ((0, Useful_1.isCross)(points)) {
                    markSymbolizer.wellKnownName = 'cross';
                }
            }
            if (!markSymbolizer.wellKnownName) {
                Logger_1.default.warn("Custom symbol not supported by MarkerSymbolyzer:\n" + JSON.stringify(mapfileStyle.symbol, null, 2));
            }
        }
        else if (mapfileStyle.symbol.character) {
            var character = mapfileStyle.symbol.character.replace(/'|"/g, '');
            if (character.length === 1) {
                markSymbolizer.wellKnownName =
                    'ttf://' + mapfileStyle.symbol.font + '#0x00' + character.charCodeAt(0).toString(16);
            }
            else {
                markSymbolizer.wellKnownName =
                    'ttf://' +
                        mapfileStyle.symbol.font +
                        '#0x' +
                        parseInt(character.replace(/&#|;/g, ''), 10).toString(16);
            }
        }
        return markSymbolizer;
    };
    /**
     * Get the GeoStyler-Style IconSymbolizer from an Mapfile Style
     *
     * @param {MapfileStyle} mapfileStyle The Mapfile Style
     * @return {IconSymbolizer} The GeoStyler-Style IconSymbolizer
     */
    MapfileStyleParser.prototype.getIconSymbolizerFromMapfileStyle = function (mapfileStyle) {
        var iconSymbolizer = {
            kind: 'Icon',
            image: mapfileStyle.symbol.image,
        };
        if (mapfileStyle.size) {
            iconSymbolizer.size = mapfileStyle.size;
        }
        iconSymbolizer.rotate = mapfileStyle.angle ? Number(mapfileStyle.angle) : 0;
        if (mapfileStyle.symbol.anchorpoint) {
            var anchorpoint = mapfileStyle.symbol.anchorpoint
                .split(' ')
                .map(function (a) { return Math.round(parseFloat(a) * 2) / 2; });
            var anchorpointMap = {
                '0.5 0.5': 'center',
                '0 0.5': 'left',
                '1 0.5': 'right',
                '0.5 0': 'top',
                '0.5 1': 'bottom',
                '0 0': 'top-left',
                '1 0': 'top-right',
                '0 1': 'bottom-left',
                '1 1': 'bottom-right',
            };
            iconSymbolizer.anchor = anchorpointMap[anchorpoint[0] + " " + anchorpoint[1]];
        }
        return iconSymbolizer;
    };
    /**
     * Get the GeoStyler-Style TextSymbolizer from an Mapfile LABEL.
     *
     * @param {MapfileLabel} labelParameters The Mapfile Label Parameters
     * @return {TextSymbolizer} The GeoStyler-Style TextSymbolizer
     */
    MapfileStyleParser.prototype.getTextSymbolizerFromMapfileStyle = function (labelParameters) {
        var textSymbolizer = { kind: 'Text' };
        if (labelParameters.text) {
            textSymbolizer.label = labelParameters.text.replace('[', '{{').replace(']', '}}');
        }
        textSymbolizer.rotate = labelParameters.angle ? Number(labelParameters.angle) : 0;
        if (labelParameters.offset) {
            var offset = labelParameters.offset.split(' ').map(function (a) { return parseFloat(a); });
            textSymbolizer.offset = [offset[0], offset[1]];
        }
        if (labelParameters.align) {
            switch (labelParameters.align.replace(/'|"/g, '')) {
                case '1':
                case 'left':
                    textSymbolizer.justify = 'left';
                    break;
                case '2':
                case 'center':
                    textSymbolizer.justify = 'center';
                    break;
                case '3':
                case 'right':
                    textSymbolizer.justify = 'right';
                    break;
                default:
                    break;
            }
        }
        if (labelParameters.buffer) {
            textSymbolizer.padding = parseFloat(labelParameters.buffer);
        }
        if (labelParameters.position) {
            var anchorpointMap = {
                cc: 'center',
                auto: 'center',
                cl: 'left',
                cr: 'right',
                uc: 'top',
                lc: 'bottom',
                ul: 'top-left',
                ur: 'top-right',
                ll: 'bottom-left',
                lr: 'bottom-right',
            };
            textSymbolizer.anchor = anchorpointMap[labelParameters.position.toLowerCase()];
        }
        if (labelParameters.font) {
            // TODO: map fonts from FONTSET
            textSymbolizer.font = [labelParameters.font];
        }
        if (labelParameters.size) {
            // TODO: deal with bitmap font sizes
            if (!(labelParameters.size in ['tiny', 'small', 'medium', 'large', 'giant'])) {
                textSymbolizer.size = parseFloat(labelParameters.size);
            }
        }
        if (labelParameters.outlinecolor) {
            textSymbolizer.haloColor = (0, Useful_1.isHex)(labelParameters.outlinecolor)
                ? labelParameters.outlinecolor
                : (0, Useful_1.rgbToHex)(labelParameters.outlinecolor);
        }
        if (labelParameters.outlinewidth) {
            textSymbolizer.haloWidth = labelParameters.outlinewidth;
        }
        return textSymbolizer;
    };
    /**
     * Get the GeoStyler-Style PointSymbolizer from an Mapfile STYLE.
     *
     * @param {MapfileStyle} mapfileStyle The Mapfile Style Parameters
     * @return {PointSymbolizer} The GeoStyler-Style PointSymbolizer
     */
    MapfileStyleParser.prototype.getPointSymbolizerFromMapfileStyle = function (mapfileStyle) {
        var pointSymbolizer = {};
        if (typeof mapfileStyle.symbol === 'object') {
            var symbolType = mapfileStyle.symbol.type;
            switch (symbolType.toLowerCase()) {
                case 'ellipse':
                case 'vector':
                case 'truetype':
                    pointSymbolizer = this.getMarkSymbolizerFromMapfileStyle(mapfileStyle);
                    break;
                case 'svg':
                    // TODO: handle as svg
                    break;
                case 'hatch':
                    // TODO
                    break;
                case 'pixmap':
                    pointSymbolizer = this.getIconSymbolizerFromMapfileStyle(mapfileStyle);
                    break;
                default:
                    break;
            }
        }
        else if (typeof mapfileStyle.symbol === 'string') {
            if (/^['"]?[^[]/.test(mapfileStyle.symbol)) {
                mapfileStyle.symbol = { image: mapfileStyle.symbol };
                pointSymbolizer = this.getIconSymbolizerFromMapfileStyle(mapfileStyle);
            }
            else {
                // TODO: handle attribute pixmaps
                Logger_1.default.error('Not able to deal with attribute pixmaps');
            }
        }
        return pointSymbolizer;
    };
    /**
     * Get the GeoStyler-Style LineSymbolizer from an Mapfile STYLE.
     *
     * @param {MapfileStyle} mapfileStyle The Mapfile Style Parameters
     * @return {LineSymbolizer} The GeoStyler-Style LineSymbolizer
     */
    MapfileStyleParser.prototype.getLineSymbolizerFromMapfileStyle = function (mapfileStyle) {
        var lineSymbolizer = { kind: 'Line' };
        if (!mapfileStyle.color && !mapfileStyle.symbol) {
            lineSymbolizer.visibility = false;
        }
        if (mapfileStyle.width) {
            lineSymbolizer.width = mapfileStyle.width * 1;
        }
        else if (mapfileStyle.symbol) {
            lineSymbolizer.width = mapfileStyle.size * 1;
        }
        if (mapfileStyle.symbol) {
            lineSymbolizer.graphicStroke = Object.assign(this.getBaseSymbolizerFromMapfileStyle(mapfileStyle), this.getPointSymbolizerFromMapfileStyle(mapfileStyle));
        }
        else {
            var linejoin = mapfileStyle.linejoin;
            if (!linejoin) {
                lineSymbolizer.join = 'round'; //  mapserver default
            }
            else if (linejoin !== 'none') {
                lineSymbolizer.join = linejoin;
            }
            if (mapfileStyle.linecap) {
                lineSymbolizer.cap = mapfileStyle.linecap;
            }
            else {
                lineSymbolizer.cap = 'round';
            }
            if (mapfileStyle.pattern) {
                lineSymbolizer.dasharray = mapfileStyle.pattern.split(' ').map(function (a) { return parseFloat(a); });
            }
            if (mapfileStyle.initialgap) {
                lineSymbolizer.dashOffset = mapfileStyle.initialgap;
            }
        }
        // TODO: does Mapfile offer such a treat?
        // lineSymbolizer.graphicFill = this.getPointSymbolizerFromMapfileStyle(styleParameters);
        return lineSymbolizer;
    };
    /**
     * Get the GeoStyler-Style FillSymbolizer from an Mapfile STYLE.
     *
     * PolygonSymbolizer Stroke is just partially supported.
     *
     * @param {MapfileStyle} mapfileStyle The Mapfile Style Parameters
     * @return {FillSymbolizer} The GeoStyler-Style FillSymbolizer
     */
    MapfileStyleParser.prototype.getFillSymbolizerFromMapfileStyle = function (mapfileStyle) {
        var fillSymbolizer = { kind: 'Fill' };
        if (!(mapfileStyle.color || mapfileStyle.outlinecolor) && !mapfileStyle.symbol) {
            fillSymbolizer.visibility = false;
        }
        else if (mapfileStyle.symbol) {
            fillSymbolizer.graphicFill = this.getPointSymbolizerFromMapfileStyle(mapfileStyle);
        }
        if (mapfileStyle.outlinecolor) {
            fillSymbolizer.outlineColor = (0, Useful_1.isHex)(mapfileStyle.outlinecolor)
                ? mapfileStyle.outlinecolor
                : (0, Useful_1.rgbToHex)(mapfileStyle.outlinecolor);
        }
        if (mapfileStyle.outlinewidth) {
            fillSymbolizer.outlineWidth = mapfileStyle.outlinewidth;
        }
        else if (mapfileStyle.width) {
            fillSymbolizer.outlineWidth = mapfileStyle.width;
        }
        if (mapfileStyle.opacity) {
            fillSymbolizer.outlineOpacity = mapfileStyle.opacity / 100;
        }
        if (mapfileStyle.pattern) {
            fillSymbolizer.outlineDasharray = mapfileStyle.pattern.split(' ').map(function (a) { return parseFloat(a); });
        }
        return fillSymbolizer;
    };
    /**
     * Get the GeoStyler-Style ColorMap from an Mapfile LAYER.
     *
     * @param {MapfileLayer} mapfileLayer The Mapfile Layer object
     * @return {ColorMap} The GeoStyler-Style ColorMap
     */
    MapfileStyleParser.prototype.getColorMapFromMapfileLayer = function (mapfileLayer) {
        // color map based on the style attributes colorrange and datarange of the first class if defined
        var mapfileClass = mapfileLayer.classes[0];
        if (mapfileLayer.classes.length === 1 && mapfileClass.styles) {
            var mapfileStyle = mapfileClass.styles[0];
            if (mapfileStyle.colorrange && mapfileStyle.datarange) {
                var colors = (0, Useful_1.rgbRangeToHexArray)(mapfileStyle.colorrange);
                var values = mapfileStyle.datarange.split(' ').map(function (element) { return parseFloat(element); });
                return {
                    type: 'ramp',
                    colorMapEntries: [
                        { color: colors[0], quantity: values[0] },
                        { color: colors[1], quantity: values[1] },
                    ],
                };
            }
        }
        else {
            Logger_1.default.warn('Raster classification not implemented!');
        }
        return;
    };
    /**
     * Get the GeoStyler-Style RasterSymbolizer from an Mapfile LAYER.
     *
     * @param {MapfileLayer} mapfileLayer The Mapfile Layer object
     * @return {RasterSymbolizer} The GeoStyler-Style RasterSymbolizer
     */
    MapfileStyleParser.prototype.getRasterSymbolizersFromMapfileLayer = function (mapfileLayer) {
        var _a, _b, _c, _d, _e, _f;
        var rasterSymbolizer = { kind: 'Raster' };
        if (((_a = mapfileLayer.classes[0]) === null || _a === void 0 ? void 0 : _a.styles) && Array.isArray((_b = mapfileLayer.classes[0]) === null || _b === void 0 ? void 0 : _b.styles)) {
            var opacity = ((_c = mapfileLayer.composite) === null || _c === void 0 ? void 0 : _c.opacity)
                ? (_d = mapfileLayer.composite) === null || _d === void 0 ? void 0 : _d.opacity
                : (_f = (_e = mapfileLayer.classes[0]) === null || _e === void 0 ? void 0 : _e.styles[0]) === null || _f === void 0 ? void 0 : _f.opacity;
            if (opacity) {
                rasterSymbolizer.opacity = opacity / 100;
            }
        }
        if (mapfileLayer.processings) {
            var processings_1 = {};
            mapfileLayer.processings.forEach(function (element) {
                var parts = element.split('=');
                processings_1[parts[0].toLowerCase()] = parts[1].toLowerCase();
            });
            switch (processings_1.resample) {
                case 'average':
                case 'bilinear':
                    rasterSymbolizer.resampling = 'linear';
                    break;
                case 'nearest':
                    rasterSymbolizer.resampling = 'nearest';
                    break;
                default:
                    break;
            }
            if (processings_1.bands) {
                var bands = processings_1.bands.split(',');
                if (bands.length === 1) {
                    rasterSymbolizer.channelSelection = { grayChannel: { sourceChannelName: bands[0] } };
                }
                else {
                    rasterSymbolizer.channelSelection = {
                        redChannel: { sourceChannelName: bands[0] },
                        greenChannel: { sourceChannelName: bands[1] },
                        blueChannel: { sourceChannelName: bands[2] },
                    };
                }
            }
        }
        var colorMap = this.getColorMapFromMapfileLayer(mapfileLayer);
        if (colorMap) {
            rasterSymbolizer.colorMap = colorMap;
        }
        return rasterSymbolizer;
    };
    /**
     * Get the GeoStyler-Style Basic Symbolizer Parameter from an Mapfile STYLE.
     *
     * @param {MapfileStyle | MapfileLabel} styleParameters The Mapfile Style
     * @return {Symbolizer} The GeoStyler-Style Symbolizer Parameters
     */
    MapfileStyleParser.prototype.getBaseSymbolizerFromMapfileStyle = function (styleParameters) {
        var symbolizer = {};
        if (styleParameters.color) {
            symbolizer.color = (0, Useful_1.isHex)(styleParameters.color)
                ? styleParameters.color
                : (0, Useful_1.rgbToHex)(styleParameters.color);
        }
        if ('opacity' in styleParameters) {
            symbolizer.opacity = styleParameters.opacity / 100;
        }
        return symbolizer;
    };
    /**
     * Get the GeoStyler-Style Symbolizers from an Mapfile CLASS.
     *
     * @param {MapfileClass} mapfileClass The Mapfile Class
     * @param {string} mapfileLayerType The Mapfile Layer Type
     * @param {string} mapfileLayerLabelItem The Mapfile Layer Label Item
     * @return {Symbolizer[]} The GeoStyler-Style Symbolizer Array
     */
    MapfileStyleParser.prototype.getSymbolizersFromClass = function (mapfileClass, mapfileLayerType, mapfileLayerLabelItem) {
        var _this = this;
        var symbolizers = [];
        // Mapfile STYLE
        if (mapfileClass.styles) {
            mapfileClass.styles.forEach(function (mapfileStyle) {
                // jump to next style block if current block is empty
                if (Object.keys(mapfileStyle).length === 0 && mapfileStyle.constructor === Object) {
                    return;
                }
                var symbolizer;
                switch (mapfileLayerType.toLowerCase()) {
                    case 'point':
                        symbolizer = _this.getPointSymbolizerFromMapfileStyle(mapfileStyle);
                        break;
                    case 'line':
                        symbolizer = _this.getLineSymbolizerFromMapfileStyle(mapfileStyle);
                        break;
                    case 'polygon':
                        symbolizer = _this.getFillSymbolizerFromMapfileStyle(mapfileStyle);
                        break;
                    case 'query':
                        // layer can be queried but not drawn
                        break;
                    case 'chart':
                    case 'circle':
                    default:
                        throw new Error('Unable to parse Symbolizer from Mapfile');
                }
                var baseSymbolizer = _this.getBaseSymbolizerFromMapfileStyle(mapfileStyle);
                symbolizers.push(Object.assign(baseSymbolizer, symbolizer));
                _this.checkWarnDropRule('MINSCALEDENOM', 'STYLE', mapfileStyle.minscaledenom);
                _this.checkWarnDropRule('MAXSCALEDENOM', 'STYLE', mapfileStyle.maxscaledenom);
            });
        }
        // Mapfile LABEL
        if (mapfileClass.labels) {
            mapfileLayerLabelItem = mapfileClass.text ? mapfileClass.text : mapfileLayerLabelItem;
            mapfileClass.labels.forEach(function (mapfileLabel) {
                mapfileLabel.text = mapfileLabel.text ? mapfileLabel.text : mapfileLayerLabelItem;
                // Set Icons in front of the associated label
                var labelIcons = _this.getIconsFromMapfileLabel(mapfileLabel);
                labelIcons.forEach(function (labelIcon) {
                    symbolizers.push(labelIcon);
                });
                var symbolizer = Object.assign(_this.getBaseSymbolizerFromMapfileStyle(mapfileLabel), _this.getTextSymbolizerFromMapfileStyle(mapfileLabel));
                symbolizers.push(symbolizer);
                _this.checkWarnDropRule('MINSCALEDENOM', 'LABEL', mapfileLabel.minscaledenom);
                _this.checkWarnDropRule('MAXSCALEDENOM', 'LABEL', mapfileLabel.maxscaledenom);
            });
        }
        return symbolizers;
    };
    /**
     * Collect icon data if defined within the label tag
     *
     * @param {MapfileLabel} mapfileLabel Mapfile label data
     * @return {IconSymbolizer[]} The IconSymbolizer
     */
    MapfileStyleParser.prototype.getIconsFromMapfileLabel = function (mapfileLabel) {
        var _this = this;
        var _a;
        var iconStyles = [];
        (_a = mapfileLabel === null || mapfileLabel === void 0 ? void 0 : mapfileLabel.styles) === null || _a === void 0 ? void 0 : _a.forEach(function (style) {
            if (style.symbol) {
                iconStyles.push(_this.getIconSymbolizerFromMapfileStyle({ symbol: { image: style.symbol } }));
            }
        });
        return iconStyles;
    };
    /**
     * Get the GeoStyler-Style Rule from an Mapfile Object.
     *
     * @param {MapfileLayer} mapfileLayer The Mapfile LAYER representation
     * @return {Rule} The GeoStyler-Style Rule
     */
    MapfileStyleParser.prototype.getRulesFromMapfileLayer = function (mapfileLayer) {
        var _this = this;
        var _a;
        var rules = [];
        var mapfileLayerType = mapfileLayer.type;
        var mapfileLayerClassItem = mapfileLayer.classitem;
        var mapfileLayerLabelItem = mapfileLayer.labelitem;
        var layerScaleDenominator = this.getScaleDenominator(mapfileLayer);
        if (mapfileLayerType.toLowerCase() === 'raster') {
            var symbolizer = this.getRasterSymbolizersFromMapfileLayer(mapfileLayer);
            var rule = { name: '' };
            if (layerScaleDenominator) {
                rule.scaleDenominator = layerScaleDenominator;
            }
            if (symbolizer) {
                rule.symbolizers = [symbolizer];
            }
            rules.push(rule);
        }
        else {
            (_a = mapfileLayer.classes) === null || _a === void 0 ? void 0 : _a.forEach(function (mapfileClass) {
                var name = mapfileClass.name || '';
                var filter = _this.getFilterFromMapfileClass(mapfileClass, mapfileLayerClassItem);
                var classScaleDenominator = _this.updateScaleDenominator(mapfileClass, layerScaleDenominator);
                var symbolizers = _this.getSymbolizersFromClass(mapfileClass, mapfileLayerType, mapfileLayerLabelItem);
                var rule = { name: name };
                if (filter) {
                    rule.filter = filter;
                }
                if (classScaleDenominator) {
                    rule.scaleDenominator = classScaleDenominator;
                }
                if (symbolizers) {
                    rule.symbolizers = symbolizers;
                }
                rules.push(rule);
            });
        }
        this.checkWarnDropRule('LABELMINSCALEDENOM', 'LAYER', mapfileLayer.labelminscaledenom);
        this.checkWarnDropRule('LABELMAXSCALEDENOM', 'LAYER', mapfileLayer.labelmaxscaledenom);
        return rules;
    };
    /**
     * Get the GeoStyler-Style Style from an Mapfile Object.
     *
     * @param {MapfileLayer} mapfileLayer The Mapfile layer object representation
     * @return {Style} The GeoStyler-Style Style
     */
    MapfileStyleParser.prototype.mapfileLayerToGeoStylerStyle = function (mapfileLayer) {
        var rules = this.getRulesFromMapfileLayer(mapfileLayer);
        var name = this.getStyleNameFromMapfileLayer(mapfileLayer);
        return {
            name: name,
            rules: rules,
        };
    };
    /**
     * The readStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads one mapfile LAYER as a string and returns a Promise.
     * If there are multiple LAYER, only the first will be read and returned.
     * The Promise itself resolves containing a GeoStyler-Style Style.
     *
     * @param  {string} mapfileString A Mapfile as a string.
     * @return {Promise} The Promise resolving containing the GeoStyler-Style Style.
     */
    MapfileStyleParser.prototype.readStyle = function (mapfileString) {
        var _this = this;
        return new Promise(function (resolve) {
            try {
                var mapfile = (0, parseMapfile_1.parseMapfile)(mapfileString, _this.symbolsPath);
                var mapfileLayers = mapfile.map.layers || [];
                if (mapfileLayers.length > 1) {
                    throw new Error('Cannot read multiple LAYER in one file. Use method readMultiStyles instead.');
                }
                var geoStylerStyle = _this.mapfileLayerToGeoStylerStyle(mapfileLayers[0]);
                resolve({
                    output: geoStylerStyle
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * Same as readStyle but read mutliple LAYER in a mapfile.
     *
     * @param  {string} mapfileString A Mapfile as a string.
     * @return {Promise} The Promise resolves containing an array of GeoStyler-Style Style.
     */
    MapfileStyleParser.prototype.readMultiStyles = function (mapfileString) {
        var _this = this;
        return new Promise(function (resolve) {
            try {
                var mapfile = (0, parseMapfile_1.parseMapfile)(mapfileString, _this.symbolsPath);
                var mapfileLayers = mapfile.map.layers || [];
                var geoStylerStyles = mapfileLayers.map(function (layer) {
                    return _this.mapfileLayerToGeoStylerStyle(layer);
                });
                resolve({
                    output: geoStylerStyles
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * The writeStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads a GeoStyler-Style Style and returns a Promise.
     * The Promise itself resolves with a Mapfile string.
     *
     * @param {Style} geoStylerStyle A GeoStyler-Style Style.
     * @return {Promise} The Promise resolving with the Mapfile as a string.
     */
    MapfileStyleParser.prototype.writeStyle = function (geoStylerStyle) {
        return new Promise(function (resolve) {
            try {
                var mapfileString = 'TODO';
                resolve({
                    output: mapfileString
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * Splits up a Mapfile Expression into its two top level Expressions
     *
     * @param {string} mapfileExpression A Mapfile Expression.
     * @return {Array<string>} The two top level expressions.
     */
    MapfileStyleParser.prototype.splitNestedExpression = function (mapfileExpression) {
        // split up nested logical combination expression leveraging parantheses
        var nestedExpressions = [];
        var index = 0;
        var fromIndex = 0;
        var parantheseCount = 0;
        for (var _i = 0, mapfileExpression_1 = mapfileExpression; _i < mapfileExpression_1.length; _i++) {
            var char = mapfileExpression_1[_i];
            switch (char) {
                case '(':
                    fromIndex = parantheseCount === 0 ? index : fromIndex;
                    parantheseCount++;
                    break;
                case ')':
                    parantheseCount--;
                    if (parantheseCount === 0) {
                        nestedExpressions.push(mapfileExpression.substring(fromIndex, index + 1));
                    }
                    break;
                default:
                    break;
            }
            index++;
        }
        return nestedExpressions;
    };
    /**
     * Generic error message for not supported rules.
     * @param {string} notSupported The not supported avoided element. Printed in the warning message.
     * @param {string} mapfileParentElement The mapfile parent element name. Printed in the warning message.
     * @param {any} mapfileElement the value to test if it existing.
     */
    MapfileStyleParser.prototype.checkWarnDropRule = function (notSupported, mapfileParentElement, mapfileElement) {
        if (mapfileElement !== undefined) {
            Logger_1.default.warn("Geostyler style does not support " + notSupported + " operator\n        in " + mapfileParentElement + ". This rule is dropped.");
        }
    };
    /**
     * The name of the Mapfile Style Parser.
     */
    MapfileStyleParser.title = 'Mapfile Style Parser';
    return MapfileStyleParser;
}());
exports.MapfileStyleParser = MapfileStyleParser;
exports.default = MapfileStyleParser;
//# sourceMappingURL=MapfileStyleParser.js.map